---
layout: post
title: 생성자에 매개변수가 많다면 빌더를 고려하라
---

정적 팩터리와 생성자에 선택적 매개변수가 많을 때 고려할 수 있는 방안
1. 점층적 생성자 패턴 또는 생성자 체이닝
   - 매개변수가 늘어나면 클라리언트 코드를 작성하기 읽기 어렵다. (cmd+p)
2. 자바빈즈 패턴
   - 완전한 객체를 만들려면 메서드를 여러번 호출해야 한다. (일관성이 무너진 상태가 될 수도 있다.
   - 클래스를 불변으로 만들 수 없다.


## 권장하는 방법 : 빌더 패턴
1. **플루언트 API** 또는 **메서드 체이닝**을 한다.   
2. 계층적으로 설계된 클래스와 함게 사용하기 좋다.
3. 점층적 생성자 보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈 보다 훨씬 안전하다.


### 자바빈즈, 게터, 세터
(주로 GUI에서) 재사용 가능한 소프트웨어 컴포넌트   
"A Java Bean is a reusable software component that can be manipulated  visually in a builder tool"   

java.beans 패키지 안에 있는 모든 것   
그 중에서도 자바빈이 지켜야할 규약
- 아규먼트 없는 기본 생성자
- getter와 setter 메서드 이름 규약
- Serializable 인터페이스 구현 (직렬화)

하지만 실제로 오늘날 자바빈 스팩 중에서도 **getter와 setter**가 주로 쓰는 이유는?
- JPA나 스프링과 같은 여러 프레임워크에서 리플렉션을 통해 특정 객체의 값을 조회하거나 설정하기 때문입니다.

### 객체 얼리기 (freezing)
임의의 객체를 불변 객체로 만들어주는 기능.   

Object.freeze()에 전달한 객체는 그뒤로 변경될 수 없다.    
 - 새 프로러티를 추가하지 못함
 - 기존 프로퍼티를 제거하지 못함
 - 기존 프로퍼티 값을 변경하지 못함
 - 프로토타입을 변경하지 못함   
strict 모드에서만 동작함   
비슷한 류의 펑션으로 Object.seal()과 Object.prevernExtensions()가 있다.

### 빌더 패턴
동일한 프로세스를 거쳐 다양한 구성의 인스턴스를 만드는 방법.   
복잡한 객체를 만드는 프로세스를 독립적으로 분리할 수 있다.

### lllegalArgumentExceoption
잘못된 인자를 넘겨 받았을 때 사용할 수 있는 기본 런타임 예외
1. checked execption과 unchecked excpetion의 차이?
2. 간혹 메소드 선언부에 unchecked excption을 선언하는 이유는?
3. checked exception은 왜 사용할까?

### 가변인수 (varags) 매개변수를 여려 개 사용할 수 있다.
여러 인자를 받을 수 있는 가변적인 argument(Var+args)   
- 가변인수는 메소드에 오직 하나만 선언할 수 있다.
- 가변인수는 메소드의 가장 마지막 매개변수가 되어야 한다.


생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는게 더 낫다. 매개변수 중 다수가 필수가 아니거나 같은 타입이면 특히 더 그렇다. 빌더는 점층적 생성자보다는 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈보다 훨씬 안전하다.