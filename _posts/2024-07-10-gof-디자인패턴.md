---
layout: post
title: GOF ë””ìì¸íŒ¨í„´
tags: [design-pattern, java]
---

GoF(Gang of Four) ë””ìì¸ íŒ¨í„´ì€ ì†Œí”„íŠ¸ì›¨ì–´ ì„¤ê³„ì˜ ë°”ì´ë¸”ì´ë‹¤. 1994ë…„ ì¶œíŒëœ **"Design Patterns: Elements of Reusable Object-Oriented Software"**ì—ì„œ ì—ë¦¬íˆ ê°ë§ˆ, ë¦¬ì²˜ë“œ í—¬ë¦„, ë„í”„ ì¡´ìŠ¨, ì¡´ ë¸”ë¦¬ì‹œë°ìŠ¤ê°€ ì •ë¦¬í•œ 23ê°€ì§€ íŒ¨í„´ì„ Java ì½”ë“œì™€ í•¨ê»˜ ì‚´í´ë³¸ë‹¤.

---

## ë””ìì¸ íŒ¨í„´ì´ë€?

ë””ìì¸ íŒ¨í„´ì€ ì†Œí”„íŠ¸ì›¨ì–´ ì„¤ê³„ì—ì„œ ë°˜ë³µì ìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ë¬¸ì œì— ëŒ€í•œ ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í•´ê²°ì±…ì´ë‹¤.

### íŒ¨í„´ì˜ êµ¬ì„± ìš”ì†Œ

| ìš”ì†Œ | ì„¤ëª… |
|------|------|
| **ì´ë¦„** | íŒ¨í„´ì„ ì‹ë³„í•˜ëŠ” ëª…ì¹­ |
| **ë¬¸ì œ** | íŒ¨í„´ì´ í•´ê²°í•˜ëŠ” ìƒí™© |
| **í•´ê²°** | ì„¤ê³„ ìš”ì†Œë“¤ì˜ êµ¬ì¡°ì™€ ê´€ê³„ |
| **ê²°ê³¼** | íŒ¨í„´ ì ìš©ì˜ ì¥ë‹¨ì  |

### íŒ¨í„´ ë¶„ë¥˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    GoF ë””ìì¸ íŒ¨í„´ (23)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ìƒì„± íŒ¨í„´ (5) â”‚ êµ¬ì¡° íŒ¨í„´ (7) â”‚      í–‰ë™ íŒ¨í„´ (11)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Singleton     â”‚ Adapter       â”‚ Strategy      â”‚ Observer    â”‚
â”‚ Factory Methodâ”‚ Bridge        â”‚ Template Methodâ”‚ State      â”‚
â”‚ Abstract Factoryâ”‚ Composite   â”‚ Command       â”‚ Mediator   â”‚
â”‚ Builder       â”‚ Decorator     â”‚ Iterator      â”‚ Memento    â”‚
â”‚ Prototype     â”‚ Facade        â”‚ Chain of Resp.â”‚ Visitor    â”‚
â”‚               â”‚ Flyweight     â”‚ Interpreter   â”‚            â”‚
â”‚               â”‚ Proxy         â”‚               â”‚            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ìƒì„± íŒ¨í„´ (Creational Patterns)

ê°ì²´ ìƒì„± ë©”ì»¤ë‹ˆì¦˜ì„ ë‹¤ë£¨ë©°, ì‹œìŠ¤í…œì´ ì–´ë–¤ êµ¬ì²´ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ”ì§€ ê°ì¶”ê³  ê°ì²´ ìƒì„±ì˜ ìœ ì—°ì„±ì„ ë†’ì¸ë‹¤.

---

## Singleton (ì‹±ê¸€í„´)

í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ ì˜¤ì§ í•˜ë‚˜ë§Œ ì¡´ì¬í•˜ë„ë¡ ë³´ì¥í•˜ê³ , ì „ì—­ ì ‘ê·¼ì ì„ ì œê³µí•œë‹¤.

### ë¬¸ì œ ìƒí™©

- ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€, ë¡œê¹…, ì„¤ì • ê´€ë¦¬ ë“± í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë§Œ í•„ìš”í•œ ê²½ìš°
- ì—¬ëŸ¬ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë˜ë©´ ë¦¬ì†ŒìŠ¤ ë‚­ë¹„ë‚˜ ì¼ê´€ì„± ë¬¸ì œ ë°œìƒ

### êµ¬í˜„ ë°©ì‹

#### 1. Eager Initialization (ì¦‰ì‹œ ì´ˆê¸°í™”)

```java
public class EagerSingleton {
    // í´ë˜ìŠ¤ ë¡œë”© ì‹œì ì— ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
    private static final EagerSingleton INSTANCE = new EagerSingleton();

    private EagerSingleton() {
        // private ìƒì„±ìë¡œ ì™¸ë¶€ ìƒì„± ë°©ì§€
    }

    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
}
```

#### 2. Lazy Initialization with Double-Checked Locking

```java
public class LazyDoubleCheckSingleton {
    // volatile: ë©”ëª¨ë¦¬ ê°€ì‹œì„± ë³´ì¥
    private static volatile LazyDoubleCheckSingleton instance;

    private LazyDoubleCheckSingleton() {}

    public static LazyDoubleCheckSingleton getInstance() {
        if (instance == null) {                    // 1ì°¨ ê²€ì‚¬ (ë½ ì—†ì´)
            synchronized (LazyDoubleCheckSingleton.class) {
                if (instance == null) {            // 2ì°¨ ê²€ì‚¬ (ë½ íšë“ í›„)
                    instance = new LazyDoubleCheckSingleton();
                }
            }
        }
        return instance;
    }
}
```

#### 3. Initialization-on-demand Holder (ê¶Œì¥)

```java
public class HolderSingleton {
    private HolderSingleton() {}

    // static inner classëŠ” ì™¸ë¶€ í´ë˜ìŠ¤ ë¡œë”© ì‹œ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ
    private static class Holder {
        private static final HolderSingleton INSTANCE = new HolderSingleton();
    }

    public static HolderSingleton getInstance() {
        return Holder.INSTANCE;  // ì´ ì‹œì ì— Holder í´ë˜ìŠ¤ ë¡œë”© ë° ì´ˆê¸°í™”
    }
}
```

#### 4. Enum Singleton (ê°€ì¥ ì•ˆì „)

```java
public enum EnumSingleton {
    INSTANCE;

    private final Connection connection;

    EnumSingleton() {
        // ì´ˆê¸°í™” ë¡œì§
        this.connection = createConnection();
    }

    private Connection createConnection() {
        // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìƒì„±
        return null;
    }

    public Connection getConnection() {
        return connection;
    }
}

// ì‚¬ìš©
EnumSingleton.INSTANCE.getConnection();
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Springì˜ ì‹±ê¸€í„´ ë¹ˆ

```java
@Configuration
public class AppConfig {

    @Bean  // ê¸°ë³¸ì ìœ¼ë¡œ ì‹±ê¸€í„´ ìŠ¤ì½”í”„
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        return new HikariDataSource(config);
    }
}
```

### ì£¼ì˜ì‚¬í•­

```
ì¥ì :
- ì¸ìŠ¤í„´ìŠ¤ê°€ í•˜ë‚˜ì„ì„ ë³´ì¥
- ì „ì—­ ì ‘ê·¼ì  ì œê³µ
- ì§€ì—° ì´ˆê¸°í™” ê°€ëŠ¥

ë‹¨ì :
- ì „ì—­ ìƒíƒœë¡œ ì¸í•œ í…ŒìŠ¤íŠ¸ ì–´ë ¤ì›€
- ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ë™ê¸°í™” í•„ìš”
- ë‹¨ì¼ ì±…ì„ ì›ì¹™ ìœ„ë°˜ ê°€ëŠ¥ì„±
```

---

## Factory Method (íŒ©í† ë¦¬ ë©”ì„œë“œ)

ê°ì²´ ìƒì„±ì„ ì„œë¸Œí´ë˜ìŠ¤ì— ìœ„ì„í•˜ì—¬, ìƒì„±í•  ê°ì²´ì˜ í´ë˜ìŠ¤ë¥¼ ì„œë¸Œí´ë˜ìŠ¤ê°€ ê²°ì •í•˜ê²Œ í•œë‹¤.

### ë¬¸ì œ ìƒí™©

```java
// ë¬¸ì œ: í´ë¼ì´ì–¸íŠ¸ ì½”ë“œê°€ êµ¬ì²´ í´ë˜ìŠ¤ì— ì˜ì¡´
public class OrderService {
    public void processOrder(String type) {
        Notification notification;

        // íƒ€ì…ì— ë”°ë¼ ì§ì ‘ ê°ì²´ ìƒì„± - OCP ìœ„ë°˜
        if (type.equals("email")) {
            notification = new EmailNotification();
        } else if (type.equals("sms")) {
            notification = new SmsNotification();
        } else if (type.equals("push")) {
            notification = new PushNotification();
        }

        notification.send();
    }
}
```

### íŒ©í† ë¦¬ ë©”ì„œë“œ ì ìš©

```java
// 1. Product ì¸í„°í˜ì´ìŠ¤
public interface Notification {
    void send(String message);
}

// 2. Concrete Products
public class EmailNotification implements Notification {
    @Override
    public void send(String message) {
        System.out.println("ì´ë©”ì¼ ë°œì†¡: " + message);
    }
}

public class SmsNotification implements Notification {
    @Override
    public void send(String message) {
        System.out.println("SMS ë°œì†¡: " + message);
    }
}

public class PushNotification implements Notification {
    @Override
    public void send(String message) {
        System.out.println("í‘¸ì‹œ ì•Œë¦¼: " + message);
    }
}

// 3. Creator (ì¶”ìƒ íŒ©í† ë¦¬)
public abstract class NotificationFactory {

    // íŒ©í† ë¦¬ ë©”ì„œë“œ - ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ êµ¬í˜„
    public abstract Notification createNotification();

    // í…œí”Œë¦¿ ë©”ì„œë“œì²˜ëŸ¼ ì‚¬ìš© ê°€ëŠ¥
    public void notify(String message) {
        Notification notification = createNotification();
        notification.send(message);
    }
}

// 4. Concrete Creators
public class EmailNotificationFactory extends NotificationFactory {
    @Override
    public Notification createNotification() {
        return new EmailNotification();
    }
}

public class SmsNotificationFactory extends NotificationFactory {
    @Override
    public Notification createNotification() {
        return new SmsNotification();
    }
}

// 5. ì‚¬ìš©
public class Client {
    public static void main(String[] args) {
        NotificationFactory factory = new EmailNotificationFactory();
        factory.notify("ì£¼ë¬¸ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");

        factory = new SmsNotificationFactory();
        factory.notify("ë°°ì†¡ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.");
    }
}
```

### Simple Factory (ë³€í˜•)

```java
// ì •ì  íŒ©í† ë¦¬ ë©”ì„œë“œ
public class NotificationSimpleFactory {

    public static Notification create(String type) {
        return switch (type.toLowerCase()) {
            case "email" -> new EmailNotification();
            case "sms" -> new SmsNotification();
            case "push" -> new PushNotification();
            default -> throw new IllegalArgumentException("Unknown type: " + type);
        };
    }
}

// ì‚¬ìš©
Notification notification = NotificationSimpleFactory.create("email");
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Springì˜ BeanFactory

```java
public interface BeanFactory {
    Object getBean(String name);
    <T> T getBean(Class<T> requiredType);
    // ...
}

// ApplicationContextê°€ BeanFactoryì˜ êµ¬í˜„ì²´ ì—­í• 
@Component
public class OrderService {

    @Autowired
    private ApplicationContext context;

    public void process() {
        // íŒ©í† ë¦¬ë¥¼ í†µí•œ ë¹ˆ ì¡°íšŒ
        PaymentProcessor processor = context.getBean(PaymentProcessor.class);
        processor.process();
    }
}
```

---

## Abstract Factory (ì¶”ìƒ íŒ©í† ë¦¬)

ê´€ë ¨ëœ ê°ì²´ë“¤ì˜ ê°€ì¡±(family)ì„ ìƒì„±í•˜ê¸° ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•œë‹¤.

### íŒ©í† ë¦¬ ë©”ì„œë“œ vs ì¶”ìƒ íŒ©í† ë¦¬

```
Factory Method:
- í•˜ë‚˜ì˜ ì œí’ˆì„ ìƒì„±
- ìƒì†ì„ í†µí•œ ê°ì²´ ìƒì„±

Abstract Factory:
- ê´€ë ¨ëœ ì œí’ˆêµ°ì„ ìƒì„±
- êµ¬ì„±(Composition)ì„ í†µí•œ ê°ì²´ ìƒì„±
```

### êµ¬í˜„ ì˜ˆì‹œ: UI ì»´í¬ë„ŒíŠ¸ íŒ©í† ë¦¬

```java
// 1. ì¶”ìƒ ì œí’ˆë“¤
public interface Button {
    void render();
    void onClick();
}

public interface Checkbox {
    void render();
    void toggle();
}

public interface TextField {
    void render();
    String getValue();
}

// 2. Windows êµ¬í˜„
public class WindowsButton implements Button {
    @Override
    public void render() {
        System.out.println("Windows ìŠ¤íƒ€ì¼ ë²„íŠ¼ ë Œë”ë§");
    }

    @Override
    public void onClick() {
        System.out.println("Windows ë²„íŠ¼ í´ë¦­");
    }
}

public class WindowsCheckbox implements Checkbox {
    @Override
    public void render() {
        System.out.println("Windows ìŠ¤íƒ€ì¼ ì²´í¬ë°•ìŠ¤ ë Œë”ë§");
    }

    @Override
    public void toggle() {
        System.out.println("Windows ì²´í¬ë°•ìŠ¤ í† ê¸€");
    }
}

// 3. MacOS êµ¬í˜„
public class MacButton implements Button {
    @Override
    public void render() {
        System.out.println("Mac ìŠ¤íƒ€ì¼ ë²„íŠ¼ ë Œë”ë§");
    }

    @Override
    public void onClick() {
        System.out.println("Mac ë²„íŠ¼ í´ë¦­");
    }
}

public class MacCheckbox implements Checkbox {
    @Override
    public void render() {
        System.out.println("Mac ìŠ¤íƒ€ì¼ ì²´í¬ë°•ìŠ¤ ë Œë”ë§");
    }

    @Override
    public void toggle() {
        System.out.println("Mac ì²´í¬ë°•ìŠ¤ í† ê¸€");
    }
}

// 4. ì¶”ìƒ íŒ©í† ë¦¬
public interface UIFactory {
    Button createButton();
    Checkbox createCheckbox();
    TextField createTextField();
}

// 5. êµ¬ì²´ íŒ©í† ë¦¬ë“¤
public class WindowsUIFactory implements UIFactory {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }

    @Override
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }

    @Override
    public TextField createTextField() {
        return new WindowsTextField();
    }
}

public class MacUIFactory implements UIFactory {
    @Override
    public Button createButton() {
        return new MacButton();
    }

    @Override
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }

    @Override
    public TextField createTextField() {
        return new MacTextField();
    }
}

// 6. í´ë¼ì´ì–¸íŠ¸ ì½”ë“œ
public class Application {
    private final Button button;
    private final Checkbox checkbox;

    public Application(UIFactory factory) {
        // êµ¬ì²´ í´ë˜ìŠ¤ì— ì˜ì¡´í•˜ì§€ ì•ŠìŒ
        this.button = factory.createButton();
        this.checkbox = factory.createCheckbox();
    }

    public void render() {
        button.render();
        checkbox.render();
    }
}

// 7. ì‚¬ìš©
public class Main {
    public static void main(String[] args) {
        UIFactory factory;

        String os = System.getProperty("os.name").toLowerCase();
        if (os.contains("win")) {
            factory = new WindowsUIFactory();
        } else {
            factory = new MacUIFactory();
        }

        Application app = new Application(factory);
        app.render();
    }
}
```

### ì‹¤ë¬´ ì˜ˆì‹œ: JDBC DriverManager

```java
// DriverManagerëŠ” ì¶”ìƒ íŒ©í† ë¦¬ íŒ¨í„´ì„ ì‚¬ìš©
// ê° DB ë²¤ë”ê°€ Connection, Statement, ResultSet ë“± ê´€ë ¨ ê°ì²´êµ°ì„ ìƒì„±

Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb", "user", "password"
);

// MySQL Driverê°€ MySQLìš© Connection, Statement ë“±ì„ ìƒì„±
Statement stmt = conn.createStatement();  // MySQLStatement
ResultSet rs = stmt.executeQuery("SELECT * FROM users");  // MySQLResultSet
```

---

## Builder (ë¹Œë”)

ë³µì¡í•œ ê°ì²´ì˜ ìƒì„± ê³¼ì •ê³¼ í‘œí˜„ì„ ë¶„ë¦¬í•˜ì—¬, ê°™ì€ ìƒì„± ê³¼ì •ì—ì„œ ë‹¤ë¥¸ í‘œí˜„ì„ ë§Œë“¤ ìˆ˜ ìˆê²Œ í•œë‹¤.

### ë¬¸ì œ ìƒí™©

```java
// ìƒì„±ì íŒŒë¼ë¯¸í„°ê°€ ë§ì€ ê²½ìš°
public class User {
    public User(String firstName, String lastName, int age,
                String phone, String address, String email,
                boolean isActive, LocalDate birthDate,
                String department, String position) {
        // íŒŒë¼ë¯¸í„° ìˆœì„œ í˜¼ë™ ê°€ëŠ¥
        // ì„ íƒì  íŒŒë¼ë¯¸í„° ì²˜ë¦¬ ì–´ë ¤ì›€
    }
}

// í…”ë ˆìŠ¤ì½”í•‘ ìƒì„±ì ì•ˆí‹°íŒ¨í„´
public User(String firstName, String lastName) { ... }
public User(String firstName, String lastName, int age) { ... }
public User(String firstName, String lastName, int age, String phone) { ... }
// ìƒì„±ìê°€ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ì¦ê°€
```

### Builder íŒ¨í„´ ì ìš©

```java
public class User {
    // í•„ìˆ˜ í•„ë“œ
    private final String firstName;
    private final String lastName;

    // ì„ íƒì  í•„ë“œ
    private final int age;
    private final String phone;
    private final String email;
    private final String address;
    private final boolean isActive;
    private final LocalDate birthDate;

    private User(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.phone = builder.phone;
        this.email = builder.email;
        this.address = builder.address;
        this.isActive = builder.isActive;
        this.birthDate = builder.birthDate;
    }

    public static class Builder {
        // í•„ìˆ˜
        private final String firstName;
        private final String lastName;

        // ì„ íƒ (ê¸°ë³¸ê°’ ì„¤ì •)
        private int age = 0;
        private String phone = "";
        private String email = "";
        private String address = "";
        private boolean isActive = true;
        private LocalDate birthDate = null;

        public Builder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder phone(String phone) {
            this.phone = phone;
            return this;
        }

        public Builder email(String email) {
            this.email = email;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        public Builder active(boolean isActive) {
            this.isActive = isActive;
            return this;
        }

        public Builder birthDate(LocalDate birthDate) {
            this.birthDate = birthDate;
            return this;
        }

        public User build() {
            // ìœ íš¨ì„± ê²€ì¦
            validate();
            return new User(this);
        }

        private void validate() {
            if (firstName == null || firstName.isBlank()) {
                throw new IllegalStateException("firstName is required");
            }
            if (age < 0) {
                throw new IllegalStateException("age cannot be negative");
            }
        }
    }

    // Getters...
}

// ì‚¬ìš©
User user = new User.Builder("í™", "ê¸¸ë™")
    .age(30)
    .email("hong@example.com")
    .phone("010-1234-5678")
    .active(true)
    .build();
```

### Lombok @Builder

```java
@Builder
@Getter
public class User {
    private final String firstName;
    private final String lastName;

    @Builder.Default
    private int age = 0;

    @Builder.Default
    private boolean isActive = true;

    private String email;
    private String phone;
}

// ì‚¬ìš©
User user = User.builder()
    .firstName("í™")
    .lastName("ê¸¸ë™")
    .email("hong@example.com")
    .build();
```

### Director íŒ¨í„´

```java
// ë³µì¡í•œ ë¹Œë“œ ê³¼ì •ì„ Directorê°€ ê´€ë¦¬
public class UserDirector {

    public User createDefaultAdmin(User.Builder builder) {
        return builder
            .active(true)
            .build();
    }

    public User createGuestUser() {
        return new User.Builder("Guest", "User")
            .active(false)
            .build();
    }
}
```

### ì‹¤ë¬´ ì˜ˆì‹œ: StringBuilder, Stream.Builder

```java
// StringBuilder
String result = new StringBuilder()
    .append("Hello")
    .append(" ")
    .append("World")
    .toString();

// Stream.Builder
Stream<String> stream = Stream.<String>builder()
    .add("one")
    .add("two")
    .add("three")
    .build();

// HttpRequest.Builder (Java 11+)
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com/users"))
    .header("Content-Type", "application/json")
    .timeout(Duration.ofSeconds(10))
    .POST(HttpRequest.BodyPublishers.ofString(jsonBody))
    .build();
```

---

## Prototype (í”„ë¡œí† íƒ€ì…)

ê¸°ì¡´ ê°ì²´ë¥¼ ë³µì œí•˜ì—¬ ìƒˆë¡œìš´ ê°ì²´ë¥¼ ìƒì„±í•œë‹¤.

### ì‚¬ìš© ì‹œì 

- ê°ì²´ ìƒì„± ë¹„ìš©ì´ ë†’ì„ ë•Œ (DB ì¡°íšŒ, ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ë“±)
- ëŸ°íƒ€ì„ì— ê°ì²´ íƒ€ì…ì´ ê²°ì •ë  ë•Œ
- í´ë˜ìŠ¤ ê³„ì¸µì´ ë³µì¡í•  ë•Œ

### êµ¬í˜„

```java
// 1. Prototype ì¸í„°í˜ì´ìŠ¤
public interface Prototype<T> extends Cloneable {
    T clone();
}

// 2. êµ¬ì²´ í”„ë¡œí† íƒ€ì…
public class Document implements Prototype<Document> {
    private String title;
    private String content;
    private List<String> authors;
    private Map<String, Object> metadata;

    public Document(String title, String content) {
        this.title = title;
        this.content = content;
        this.authors = new ArrayList<>();
        this.metadata = new HashMap<>();
    }

    // ë³µì‚¬ ìƒì„±ì
    private Document(Document source) {
        this.title = source.title;
        this.content = source.content;
        // ê¹Šì€ ë³µì‚¬
        this.authors = new ArrayList<>(source.authors);
        this.metadata = new HashMap<>(source.metadata);
    }

    @Override
    public Document clone() {
        return new Document(this);
    }

    // Getters and Setters...
}

// 3. ì‚¬ìš©
Document original = new Document("ì œëª©", "ë‚´ìš©");
original.getAuthors().add("ì‘ì„±ì1");

Document copy = original.clone();
copy.setTitle("ë³µì‚¬ë³¸ ì œëª©");
copy.getAuthors().add("ì‘ì„±ì2");

// original.authors: [ì‘ì„±ì1]
// copy.authors: [ì‘ì„±ì1, ì‘ì„±ì2]
```

### í”„ë¡œí† íƒ€ì… ë ˆì§€ìŠ¤íŠ¸ë¦¬

```java
public class DocumentRegistry {
    private final Map<String, Document> prototypes = new HashMap<>();

    public void register(String key, Document prototype) {
        prototypes.put(key, prototype);
    }

    public Document create(String key) {
        Document prototype = prototypes.get(key);
        if (prototype == null) {
            throw new IllegalArgumentException("Unknown prototype: " + key);
        }
        return prototype.clone();
    }
}

// ì‚¬ìš©
DocumentRegistry registry = new DocumentRegistry();

// í…œí”Œë¦¿ ë“±ë¡
Document reportTemplate = new Document("ì›”ê°„ ë³´ê³ ì„œ", "");
reportTemplate.getMetadata().put("type", "report");
registry.register("monthly-report", reportTemplate);

// ë³µì œí•˜ì—¬ ì‚¬ìš©
Document januaryReport = registry.create("monthly-report");
januaryReport.setTitle("2024ë…„ 1ì›” ë³´ê³ ì„œ");
```

### ì–•ì€ ë³µì‚¬ vs ê¹Šì€ ë³µì‚¬

```java
public class ShallowVsDeep {

    // ì–•ì€ ë³µì‚¬ - ì°¸ì¡°ë§Œ ë³µì‚¬
    public static Document shallowCopy(Document source) {
        Document copy = new Document(source.getTitle(), source.getContent());
        copy.setAuthors(source.getAuthors());  // ê°™ì€ List ì°¸ì¡°
        return copy;
    }

    // ê¹Šì€ ë³µì‚¬ - ê°ì²´ ì „ì²´ ë³µì‚¬
    public static Document deepCopy(Document source) {
        Document copy = new Document(source.getTitle(), source.getContent());
        copy.setAuthors(new ArrayList<>(source.getAuthors()));  // ìƒˆ List ìƒì„±

        // ì¤‘ì²© ê°ì²´ë„ ë³µì‚¬
        Map<String, Object> metaCopy = new HashMap<>();
        for (Map.Entry<String, Object> entry : source.getMetadata().entrySet()) {
            // ê°’ì´ ì»¬ë ‰ì…˜ì´ë©´ ê·¸ê²ƒë„ ë³µì‚¬
            if (entry.getValue() instanceof List) {
                metaCopy.put(entry.getKey(), new ArrayList<>((List<?>) entry.getValue()));
            } else {
                metaCopy.put(entry.getKey(), entry.getValue());
            }
        }
        copy.setMetadata(metaCopy);

        return copy;
    }
}
```

---

# êµ¬ì¡° íŒ¨í„´ (Structural Patterns)

í´ë˜ìŠ¤ë‚˜ ê°ì²´ë¥¼ ì¡°í•©í•˜ì—¬ ë” í° êµ¬ì¡°ë¥¼ ë§Œë“œëŠ” ë°©ë²•ì„ ë‹¤ë£¬ë‹¤.

---

## Adapter (ì–´ëŒ‘í„°)

í˜¸í™˜ë˜ì§€ ì•ŠëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ê°€ì§„ í´ë˜ìŠ¤ë“¤ì´ í•¨ê»˜ ë™ì‘í•  ìˆ˜ ìˆê²Œ í•œë‹¤.

### ë¬¸ì œ ìƒí™©

```java
// ê¸°ì¡´ ì‹œìŠ¤í…œì˜ ì¸í„°í˜ì´ìŠ¤
public interface MediaPlayer {
    void play(String audioType, String fileName);
}

// ìƒˆë¡œ ë„ì…í•˜ë ¤ëŠ” ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬
public class VlcPlayer {
    public void playVlc(String fileName) {
        System.out.println("Playing vlc file: " + fileName);
    }
}

public class Mp4Player {
    public void playMp4(String fileName) {
        System.out.println("Playing mp4 file: " + fileName);
    }
}
```

### ì–´ëŒ‘í„° ì ìš© (Object Adapter)

```java
// ê³ ê¸‰ ë¯¸ë””ì–´ í”Œë ˆì´ì–´ ì¸í„°í˜ì´ìŠ¤
public interface AdvancedMediaPlayer {
    void playAdvanced(String fileName);
}

// VLC ì–´ëŒ‘í„°
public class VlcPlayerAdapter implements AdvancedMediaPlayer {
    private final VlcPlayer vlcPlayer;

    public VlcPlayerAdapter() {
        this.vlcPlayer = new VlcPlayer();
    }

    @Override
    public void playAdvanced(String fileName) {
        vlcPlayer.playVlc(fileName);
    }
}

// MP4 ì–´ëŒ‘í„°
public class Mp4PlayerAdapter implements AdvancedMediaPlayer {
    private final Mp4Player mp4Player;

    public Mp4PlayerAdapter() {
        this.mp4Player = new Mp4Player();
    }

    @Override
    public void playAdvanced(String fileName) {
        mp4Player.playMp4(fileName);
    }
}

// í†µí•© ë¯¸ë””ì–´ í”Œë ˆì´ì–´
public class AudioPlayer implements MediaPlayer {

    @Override
    public void play(String audioType, String fileName) {
        AdvancedMediaPlayer player = switch (audioType.toLowerCase()) {
            case "vlc" -> new VlcPlayerAdapter();
            case "mp4" -> new Mp4PlayerAdapter();
            default -> throw new IllegalArgumentException("Unsupported format: " + audioType);
        };
        player.playAdvanced(fileName);
    }
}
```

### Class Adapter (ìƒì† ë°©ì‹)

```java
// ë‹¤ì¤‘ ìƒì†ì´ ë¶ˆê°€ëŠ¥í•œ Javaì—ì„œëŠ” ì¸í„°í˜ì´ìŠ¤ + ìƒì† ì¡°í•©
public class VlcClassAdapter extends VlcPlayer implements AdvancedMediaPlayer {

    @Override
    public void playAdvanced(String fileName) {
        // ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ë©”ì„œë“œ í˜¸ì¶œ
        super.playVlc(fileName);
    }
}
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Spring HandlerAdapter

```java
// Spring MVCì˜ HandlerAdapter
public interface HandlerAdapter {
    boolean supports(Object handler);
    ModelAndView handle(HttpServletRequest request,
                        HttpServletResponse response,
                        Object handler) throws Exception;
}

// ê° í•¸ë“¤ëŸ¬ íƒ€ì…ì— ë§ëŠ” ì–´ëŒ‘í„°
public class RequestMappingHandlerAdapter implements HandlerAdapter {
    @Override
    public boolean supports(Object handler) {
        return handler instanceof HandlerMethod;
    }

    @Override
    public ModelAndView handle(HttpServletRequest request,
                                HttpServletResponse response,
                                Object handler) throws Exception {
        // @RequestMapping ë©”ì„œë“œ ì‹¤í–‰
        return invokeHandlerMethod(request, response, (HandlerMethod) handler);
    }
}
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Enumeration to Iterator

```java
// Javaì˜ Collections.enumeration()ê³¼ ë°˜ëŒ€ ë°©í–¥
public class EnumerationIteratorAdapter<T> implements Iterator<T> {
    private final Enumeration<T> enumeration;

    public EnumerationIteratorAdapter(Enumeration<T> enumeration) {
        this.enumeration = enumeration;
    }

    @Override
    public boolean hasNext() {
        return enumeration.hasMoreElements();
    }

    @Override
    public T next() {
        return enumeration.nextElement();
    }
}
```

---

## Bridge (ë¸Œë¦¬ì§€)

êµ¬í˜„ì—ì„œ ì¶”ìƒì„ ë¶„ë¦¬í•˜ì—¬ ë…ë¦½ì ìœ¼ë¡œ ë³€í˜•í•  ìˆ˜ ìˆê²Œ í•œë‹¤.

### ë¬¸ì œ ìƒí™©

```
ìƒì†ìœ¼ë¡œ í™•ì¥í•˜ë©´ ì¡°í•© í­ë°œ:
- Shape: Circle, Square, Triangle
- Color: Red, Blue, Green

ìƒì†: RedCircle, BlueCircle, GreenCircle, RedSquare, BlueSquare...
â†’ 3 x 3 = 9ê°œ í´ë˜ìŠ¤

ë¸Œë¦¬ì§€: Shape + Color ì¡°í•©
â†’ 3 + 3 = 6ê°œ í´ë˜ìŠ¤
```

### ë¸Œë¦¬ì§€ íŒ¨í„´ ì ìš©

```java
// 1. Implementor - êµ¬í˜„ ê³„ì¸µ
public interface Color {
    String fill();
}

public class Red implements Color {
    @Override
    public String fill() {
        return "ë¹¨ê°„ìƒ‰";
    }
}

public class Blue implements Color {
    @Override
    public String fill() {
        return "íŒŒë€ìƒ‰";
    }
}

// 2. Abstraction - ì¶”ìƒ ê³„ì¸µ
public abstract class Shape {
    protected Color color;  // Bridge: êµ¬í˜„ì„ ì°¸ì¡°

    protected Shape(Color color) {
        this.color = color;
    }

    public abstract void draw();
}

// 3. Refined Abstraction
public class Circle extends Shape {
    private final int radius;

    public Circle(int radius, Color color) {
        super(color);
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println(color.fill() + " ì› (ë°˜ì§€ë¦„: " + radius + ")");
    }
}

public class Square extends Shape {
    private final int side;

    public Square(int side, Color color) {
        super(color);
        this.side = side;
    }

    @Override
    public void draw() {
        System.out.println(color.fill() + " ì‚¬ê°í˜• (ë³€: " + side + ")");
    }
}

// 4. ì‚¬ìš©
Shape redCircle = new Circle(10, new Red());
Shape blueSquare = new Square(20, new Blue());

redCircle.draw();   // ë¹¨ê°„ìƒ‰ ì› (ë°˜ì§€ë¦„: 10)
blueSquare.draw();  // íŒŒë€ìƒ‰ ì‚¬ê°í˜• (ë³€: 20)
```

### ì‹¤ë¬´ ì˜ˆì‹œ: ë¦¬ëª¨ì»¨ê³¼ ë””ë°”ì´ìŠ¤

```java
// Device êµ¬í˜„
public interface Device {
    void turnOn();
    void turnOff();
    void setVolume(int volume);
    int getVolume();
}

public class TV implements Device {
    private boolean on = false;
    private int volume = 30;

    @Override
    public void turnOn() { on = true; }

    @Override
    public void turnOff() { on = false; }

    @Override
    public void setVolume(int volume) { this.volume = volume; }

    @Override
    public int getVolume() { return volume; }
}

public class Radio implements Device {
    // ë¹„ìŠ·í•œ êµ¬í˜„...
}

// Remote ì¶”ìƒí™”
public abstract class Remote {
    protected Device device;

    protected Remote(Device device) {
        this.device = device;
    }

    public void togglePower() {
        // device ìƒíƒœì— ë”°ë¼ on/off
    }

    public void volumeUp() {
        device.setVolume(device.getVolume() + 10);
    }

    public void volumeDown() {
        device.setVolume(device.getVolume() - 10);
    }
}

// ê³ ê¸‰ ë¦¬ëª¨ì»¨
public class AdvancedRemote extends Remote {
    public AdvancedRemote(Device device) {
        super(device);
    }

    public void mute() {
        device.setVolume(0);
    }
}

// ì‚¬ìš©
Device tv = new TV();
Remote remote = new AdvancedRemote(tv);
remote.volumeUp();
((AdvancedRemote) remote).mute();
```

### ì‹¤ë¬´ ì˜ˆì‹œ: JDBC Driver

```java
// DriverManager(ì¶”ìƒ) + Driver(êµ¬í˜„)ì˜ ë¸Œë¦¬ì§€ êµ¬ì¡°
// ì¶”ìƒ: java.sql.Connection, Statement, ResultSet
// êµ¬í˜„: MySQL Driver, Oracle Driver, PostgreSQL Driver

// ë™ì¼í•œ JDBC APIë¡œ ë‹¤ì–‘í•œ DB ì‚¬ìš©
Connection mysqlConn = DriverManager.getConnection("jdbc:mysql://...");
Connection oracleConn = DriverManager.getConnection("jdbc:oracle://...");
```

---

## Composite (ì»´í¬ì§€íŠ¸)

ê°ì²´ë“¤ì„ íŠ¸ë¦¬ êµ¬ì¡°ë¡œ êµ¬ì„±í•˜ì—¬ ê°œë³„ ê°ì²´ì™€ ë³µí•© ê°ì²´ë¥¼ ë™ì¼í•˜ê²Œ ë‹¤ë£¬ë‹¤.

### êµ¬í˜„

```java
// 1. Component
public interface FileSystemComponent {
    String getName();
    long getSize();
    void print(String prefix);
}

// 2. Leaf
public class File implements FileSystemComponent {
    private final String name;
    private final long size;

    public File(String name, long size) {
        this.name = name;
        this.size = size;
    }

    @Override
    public String getName() { return name; }

    @Override
    public long getSize() { return size; }

    @Override
    public void print(String prefix) {
        System.out.println(prefix + "ğŸ“„ " + name + " (" + size + " bytes)");
    }
}

// 3. Composite
public class Directory implements FileSystemComponent {
    private final String name;
    private final List<FileSystemComponent> children = new ArrayList<>();

    public Directory(String name) {
        this.name = name;
    }

    public void add(FileSystemComponent component) {
        children.add(component);
    }

    public void remove(FileSystemComponent component) {
        children.remove(component);
    }

    @Override
    public String getName() { return name; }

    @Override
    public long getSize() {
        return children.stream()
            .mapToLong(FileSystemComponent::getSize)
            .sum();
    }

    @Override
    public void print(String prefix) {
        System.out.println(prefix + "ğŸ“ " + name + " (" + getSize() + " bytes)");
        for (FileSystemComponent child : children) {
            child.print(prefix + "  ");
        }
    }
}

// 4. ì‚¬ìš©
Directory root = new Directory("root");
Directory src = new Directory("src");
Directory test = new Directory("test");

src.add(new File("Main.java", 1000));
src.add(new File("Utils.java", 500));

test.add(new File("MainTest.java", 800));

root.add(src);
root.add(test);
root.add(new File("README.md", 200));

root.print("");
// ì¶œë ¥:
// ğŸ“ root (2500 bytes)
//   ğŸ“ src (1500 bytes)
//     ğŸ“„ Main.java (1000 bytes)
//     ğŸ“„ Utils.java (500 bytes)
//   ğŸ“ test (800 bytes)
//     ğŸ“„ MainTest.java (800 bytes)
//   ğŸ“„ README.md (200 bytes)
```

### ì‹¤ë¬´ ì˜ˆì‹œ: ì¡°ì§ë„

```java
public interface OrganizationComponent {
    String getName();
    void showDetails();
    int getHeadCount();
}

public class Employee implements OrganizationComponent {
    private final String name;
    private final String position;

    // Leaf êµ¬í˜„...

    @Override
    public int getHeadCount() { return 1; }
}

public class Department implements OrganizationComponent {
    private final String name;
    private final List<OrganizationComponent> members = new ArrayList<>();

    // Composite êµ¬í˜„...

    @Override
    public int getHeadCount() {
        return members.stream()
            .mapToInt(OrganizationComponent::getHeadCount)
            .sum();
    }
}
```

---

## Decorator (ë°ì½”ë ˆì´í„°)

ê°ì²´ì— ë™ì ìœ¼ë¡œ ìƒˆë¡œìš´ ì±…ì„ì„ ì¶”ê°€í•œë‹¤. ìƒì† ì—†ì´ ê¸°ëŠ¥ì„ í™•ì¥í•  ìˆ˜ ìˆë‹¤.

### ìƒì† vs ë°ì½”ë ˆì´í„°

```
ìƒì†ì˜ ë¬¸ì œ:
- ì»´íŒŒì¼ íƒ€ì„ì— ê³ ì •
- ì¡°í•© í­ë°œ (MilkCoffee, SugarCoffee, MilkSugarCoffee...)
- ë‹¨ì¼ ìƒì† ì œí•œ

ë°ì½”ë ˆì´í„°ì˜ ì¥ì :
- ëŸ°íƒ€ì„ì— ë™ì  ì¡°í•©
- ë‹¨ì¼ ì±…ì„ ì›ì¹™ ì¤€ìˆ˜
- ê¸°ì¡´ ì½”ë“œ ë³€ê²½ ì—†ì´ í™•ì¥
```

### êµ¬í˜„

```java
// 1. Component
public interface Coffee {
    String getDescription();
    double getCost();
}

// 2. Concrete Component
public class Espresso implements Coffee {
    @Override
    public String getDescription() { return "ì—ìŠ¤í”„ë ˆì†Œ"; }

    @Override
    public double getCost() { return 2000; }
}

public class Americano implements Coffee {
    @Override
    public String getDescription() { return "ì•„ë©”ë¦¬ì¹´ë…¸"; }

    @Override
    public double getCost() { return 3000; }
}

// 3. Decorator (ì¶”ìƒ)
public abstract class CoffeeDecorator implements Coffee {
    protected final Coffee coffee;

    protected CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }

    @Override
    public String getDescription() {
        return coffee.getDescription();
    }

    @Override
    public double getCost() {
        return coffee.getCost();
    }
}

// 4. Concrete Decorators
public class Milk extends CoffeeDecorator {
    public Milk(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return coffee.getDescription() + ", ìš°ìœ ";
    }

    @Override
    public double getCost() {
        return coffee.getCost() + 500;
    }
}

public class Whip extends CoffeeDecorator {
    public Whip(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return coffee.getDescription() + ", íœ˜í•‘í¬ë¦¼";
    }

    @Override
    public double getCost() {
        return coffee.getCost() + 700;
    }
}

public class Shot extends CoffeeDecorator {
    public Shot(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return coffee.getDescription() + ", ìƒ· ì¶”ê°€";
    }

    @Override
    public double getCost() {
        return coffee.getCost() + 500;
    }
}

// 5. ì‚¬ìš©
Coffee order = new Espresso();
order = new Milk(order);
order = new Whip(order);
order = new Shot(order);

System.out.println(order.getDescription());  // ì—ìŠ¤í”„ë ˆì†Œ, ìš°ìœ , íœ˜í•‘í¬ë¦¼, ìƒ· ì¶”ê°€
System.out.println(order.getCost());         // 3700.0

// Fluent ë°©ì‹
Coffee order2 = new Shot(new Whip(new Milk(new Americano())));
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Java I/O

```java
// Java I/OëŠ” ë°ì½”ë ˆì´í„° íŒ¨í„´ì˜ ëŒ€í‘œì  ì˜ˆ
InputStream is = new FileInputStream("file.txt");

// BufferedInputStreamì´ FileInputStreamì„ ë°ì½”ë ˆì´íŠ¸
InputStream buffered = new BufferedInputStream(is);

// DataInputStreamì´ BufferedInputStreamì„ ë°ì½”ë ˆì´íŠ¸
DataInputStream data = new DataInputStream(buffered);

// í•œ ì¤„ë¡œ ì²´ì´ë‹
DataInputStream stream = new DataInputStream(
    new BufferedInputStream(
        new FileInputStream("file.txt")
    )
);
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Springì˜ HandlerInterceptor

```java
// ì¸í„°ì…‰í„°ë“¤ì´ í•¸ë“¤ëŸ¬ë¥¼ ë°ì½”ë ˆì´íŠ¸í•˜ëŠ” ê²ƒì²˜ëŸ¼ ë™ì‘
public class LoggingInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler) {
        log.info("Request: {} {}", request.getMethod(), request.getRequestURI());
        return true;
    }
}
```

---

## Facade (í¼ì‚¬ë“œ)

ì„œë¸Œì‹œìŠ¤í…œì— ëŒ€í•œ í†µí•©ëœ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ì—¬ ì„œë¸Œì‹œìŠ¤í…œì„ ë” ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•œë‹¤.

### êµ¬í˜„

```java
// ë³µì¡í•œ ì„œë¸Œì‹œìŠ¤í…œë“¤
public class VideoFile {
    private final String name;
    private final String codecType;

    public VideoFile(String name) {
        this.name = name;
        this.codecType = name.substring(name.lastIndexOf('.') + 1);
    }
    // ...
}

public class CodecFactory {
    public static Codec extract(VideoFile file) {
        String type = file.getCodecType();
        if (type.equals("mp4")) {
            return new MPEG4CompressionCodec();
        } else {
            return new OggCompressionCodec();
        }
    }
}

public class BitrateReader {
    public static VideoFile read(VideoFile file, Codec codec) {
        System.out.println("BitrateReader: íŒŒì¼ ì½ê¸°...");
        return file;
    }

    public static VideoFile convert(VideoFile buffer, Codec codec) {
        System.out.println("BitrateReader: ë³€í™˜ ì¤‘...");
        return buffer;
    }
}

public class AudioMixer {
    public File fix(VideoFile result) {
        System.out.println("AudioMixer: ì˜¤ë””ì˜¤ ë¯¹ì‹±...");
        return new File("");
    }
}

// Facade
public class VideoConversionFacade {

    public File convertVideo(String fileName, String format) {
        System.out.println("VideoConversionFacade: ë³€í™˜ ì‹œì‘");

        VideoFile file = new VideoFile(fileName);
        Codec sourceCodec = CodecFactory.extract(file);

        Codec destinationCodec;
        if (format.equals("mp4")) {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }

        VideoFile buffer = BitrateReader.read(file, sourceCodec);
        VideoFile intermediateResult = BitrateReader.convert(buffer, destinationCodec);

        File result = new AudioMixer().fix(intermediateResult);

        System.out.println("VideoConversionFacade: ë³€í™˜ ì™„ë£Œ");
        return result;
    }
}

// í´ë¼ì´ì–¸íŠ¸ ì½”ë“œ - ë§¤ìš° ë‹¨ìˆœí•´ì§
public class Client {
    public static void main(String[] args) {
        VideoConversionFacade converter = new VideoConversionFacade();
        File mp4 = converter.convertVideo("video.ogg", "mp4");
    }
}
```

### ì‹¤ë¬´ ì˜ˆì‹œ: SLF4J

```java
// SLF4JëŠ” ë‹¤ì–‘í•œ ë¡œê¹… í”„ë ˆì„ì›Œí¬ì— ëŒ€í•œ Facade
// Log4j, Logback, JUL ë“± ì‹¤ì œ êµ¬í˜„ì„ ê°ì¶¤

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyService {
    private static final Logger log = LoggerFactory.getLogger(MyService.class);

    public void doSomething() {
        log.info("ì‘ì—… ì‹œì‘");  // ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–¤ ë¡œê±°ê°€ ì“°ì´ëŠ”ì§€ ëª¨ë¦„
    }
}
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Springì˜ JdbcTemplate

```java
// JdbcTemplateì€ JDBCì˜ ë³µì¡í•¨ì„ ìˆ¨ê¸°ëŠ” Facade
@Repository
public class UserRepository {

    private final JdbcTemplate jdbcTemplate;

    public User findById(Long id) {
        // Connection íšë“, PreparedStatement ìƒì„±, ResultSet ì²˜ë¦¬,
        // ì˜ˆì™¸ ë³€í™˜, ìì› í•´ì œ ë“±ì„ ëª¨ë‘ JdbcTemplateì´ ì²˜ë¦¬
        return jdbcTemplate.queryForObject(
            "SELECT * FROM users WHERE id = ?",
            (rs, rowNum) -> new User(
                rs.getLong("id"),
                rs.getString("name")
            ),
            id
        );
    }
}
```

---

## Flyweight (í”Œë¼ì´ì›¨ì´íŠ¸)

ë§ì€ ìˆ˜ì˜ ìœ ì‚¬í•œ ê°ì²´ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê³µìœ í•˜ì—¬ ë©”ëª¨ë¦¬ ì‚¬ìš©ì„ ìµœì†Œí™”í•œë‹¤.

### ê°œë…

```
Intrinsic State (ë‚´ì¬ ìƒíƒœ):
- ê°ì²´ ê°„ì— ê³µìœ ë˜ëŠ” ë¶ˆë³€ ë°ì´í„°
- Flyweight ê°ì²´ ë‚´ë¶€ì— ì €ì¥

Extrinsic State (ì™¸ì¬ ìƒíƒœ):
- ê° ê°ì²´ë§ˆë‹¤ ë‹¤ë¥¸ ì»¨í…ìŠ¤íŠ¸ ì˜ì¡´ ë°ì´í„°
- í´ë¼ì´ì–¸íŠ¸ê°€ ì „ë‹¬
```

### êµ¬í˜„

```java
// 1. Flyweight - ê³µìœ ë˜ëŠ” ê°ì²´
public class TreeType {
    private final String name;
    private final String color;
    private final String texture;  // ìš©ëŸ‰ì´ í° í…ìŠ¤ì²˜ ë°ì´í„°

    public TreeType(String name, String color, String texture) {
        this.name = name;
        this.color = color;
        this.texture = texture;
    }

    public void draw(int x, int y) {
        System.out.printf("%s ë‚˜ë¬´ë¥¼ (%d, %d)ì— ê·¸ë¦½ë‹ˆë‹¤. ìƒ‰ìƒ: %s%n",
            name, x, y, color);
    }
}

// 2. Flyweight Factory
public class TreeFactory {
    private static final Map<String, TreeType> treeTypes = new HashMap<>();

    public static TreeType getTreeType(String name, String color, String texture) {
        String key = name + "_" + color + "_" + texture;

        if (!treeTypes.containsKey(key)) {
            treeTypes.put(key, new TreeType(name, color, texture));
            System.out.println("ìƒˆë¡œìš´ TreeType ìƒì„±: " + key);
        }

        return treeTypes.get(key);
    }

    public static int getTypeCount() {
        return treeTypes.size();
    }
}

// 3. Context - ì™¸ì¬ ìƒíƒœë¥¼ ê°€ì§„ ê°ì²´
public class Tree {
    private final int x;
    private final int y;
    private final TreeType type;  // Flyweight ì°¸ì¡°

    public Tree(int x, int y, TreeType type) {
        this.x = x;
        this.y = y;
        this.type = type;
    }

    public void draw() {
        type.draw(x, y);
    }
}

// 4. ìˆ² (í´ë¼ì´ì–¸íŠ¸)
public class Forest {
    private final List<Tree> trees = new ArrayList<>();

    public void plantTree(int x, int y, String name, String color, String texture) {
        TreeType type = TreeFactory.getTreeType(name, color, texture);
        Tree tree = new Tree(x, y, type);
        trees.add(tree);
    }

    public void draw() {
        for (Tree tree : trees) {
            tree.draw();
        }
    }
}

// 5. ì‚¬ìš©
Forest forest = new Forest();

// 100ë§Œ ê·¸ë£¨ì˜ ë‚˜ë¬´ë¥¼ ì‹¬ì–´ë„ TreeTypeì€ ëª‡ ê°œë§Œ ìƒì„±
for (int i = 0; i < 1_000_000; i++) {
    int x = (int) (Math.random() * 1000);
    int y = (int) (Math.random() * 1000);

    // ë‚˜ë¬´ ì¢…ë¥˜ëŠ” 3ê°€ì§€ë¿
    String[] names = {"ì†Œë‚˜ë¬´", "ì°¸ë‚˜ë¬´", "ë‹¨í’ë‚˜ë¬´"};
    String[] colors = {"ì´ˆë¡", "ì§„ì´ˆë¡", "ë¹¨ê°•"};

    int typeIndex = i % 3;
    forest.plantTree(x, y, names[typeIndex], colors[typeIndex], "texture_" + typeIndex);
}

System.out.println("TreeType ê°œìˆ˜: " + TreeFactory.getTypeCount());  // 3
// 100ë§Œ Tree ê°ì²´ê°€ 3ê°œì˜ TreeTypeë§Œ ê³µìœ 
```

### ì‹¤ë¬´ ì˜ˆì‹œ: String Pool

```java
// Javaì˜ String Poolì´ Flyweight íŒ¨í„´
String s1 = "hello";  // Poolì—ì„œ ê°€ì ¸ì˜´
String s2 = "hello";  // ê°™ì€ ê°ì²´ ì°¸ì¡°

System.out.println(s1 == s2);  // true

String s3 = new String("hello");  // ìƒˆ ê°ì²´ ìƒì„±
System.out.println(s1 == s3);  // false

String s4 = s3.intern();  // Poolë¡œ ì´ë™
System.out.println(s1 == s4);  // true
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Integer Cache

```java
// Integer -128 ~ 127ì€ ìºì‹œë¨
Integer a = 100;
Integer b = 100;
System.out.println(a == b);  // true

Integer c = 200;
Integer d = 200;
System.out.println(c == d);  // false
```

---

## Proxy (í”„ë¡ì‹œ)

ë‹¤ë¥¸ ê°ì²´ì— ëŒ€í•œ ëŒ€ë¦¬ìë¥¼ ì œê³µí•˜ì—¬ ì ‘ê·¼ì„ ì œì–´í•œë‹¤.

### í”„ë¡ì‹œ ì¢…ë¥˜

| ì¢…ë¥˜ | ëª©ì  |
|------|------|
| **Virtual Proxy** | ì§€ì—° ë¡œë”© (ë¹„ìš©ì´ í° ê°ì²´) |
| **Protection Proxy** | ì ‘ê·¼ ê¶Œí•œ ì œì–´ |
| **Remote Proxy** | ì›ê²© ê°ì²´ ì ‘ê·¼ |
| **Caching Proxy** | ê²°ê³¼ ìºì‹± |
| **Logging Proxy** | ë¡œê¹… ì¶”ê°€ |

### Virtual Proxy (ì§€ì—° ë¡œë”©)

```java
// 1. Subject
public interface Image {
    void display();
}

// 2. Real Subject
public class HighResolutionImage implements Image {
    private final String filename;
    private byte[] imageData;

    public HighResolutionImage(String filename) {
        this.filename = filename;
        loadFromDisk();  // ë¬´ê±°ìš´ ì‘ì—…
    }

    private void loadFromDisk() {
        System.out.println("Loading image: " + filename);
        // ì‹¤ì œë¡œëŠ” íŒŒì¼ ì½ê¸°, ë””ì½”ë”© ë“± ì‹œê°„ì´ ê±¸ë¦¼
        try { Thread.sleep(2000); } catch (InterruptedException e) {}
        this.imageData = new byte[1024 * 1024];  // 1MB ì´ë¯¸ì§€ ë°ì´í„°
    }

    @Override
    public void display() {
        System.out.println("Displaying: " + filename);
    }
}

// 3. Proxy
public class ImageProxy implements Image {
    private final String filename;
    private HighResolutionImage realImage;  // ì§€ì—° ìƒì„±

    public ImageProxy(String filename) {
        this.filename = filename;
        // ì‹¤ì œ ì´ë¯¸ì§€ëŠ” ì•„ì§ ë¡œë”©í•˜ì§€ ì•ŠìŒ
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new HighResolutionImage(filename);
        }
        realImage.display();
    }
}

// 4. ì‚¬ìš©
Image image1 = new ImageProxy("photo1.jpg");
Image image2 = new ImageProxy("photo2.jpg");
Image image3 = new ImageProxy("photo3.jpg");

// ì•„ì§ ì•„ë¬´ê²ƒë„ ë¡œë”©ë˜ì§€ ì•ŠìŒ
System.out.println("Images created");

// ì´ ì‹œì ì—ë§Œ photo1.jpg ë¡œë”©
image1.display();
```

### Protection Proxy (ì ‘ê·¼ ì œì–´)

```java
public interface Document {
    void read();
    void write(String content);
}

public class SecureDocument implements Document {
    private String content;

    @Override
    public void read() {
        System.out.println("Content: " + content);
    }

    @Override
    public void write(String content) {
        this.content = content;
    }
}

public class DocumentProxy implements Document {
    private final SecureDocument document;
    private final String currentUser;
    private final Set<String> admins = Set.of("admin", "manager");

    public DocumentProxy(SecureDocument document, String currentUser) {
        this.document = document;
        this.currentUser = currentUser;
    }

    @Override
    public void read() {
        document.read();  // ì½ê¸°ëŠ” ëª¨ë‘ í—ˆìš©
    }

    @Override
    public void write(String content) {
        if (admins.contains(currentUser)) {
            document.write(content);
        } else {
            throw new SecurityException("ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤: " + currentUser);
        }
    }
}
```

### Caching Proxy

```java
public interface UserService {
    User findById(Long id);
}

public class UserServiceImpl implements UserService {
    @Override
    public User findById(Long id) {
        System.out.println("DB ì¡°íšŒ: " + id);
        // ì‹¤ì œ DB ì¡°íšŒ
        return new User(id, "User " + id);
    }
}

public class CachingUserServiceProxy implements UserService {
    private final UserService target;
    private final Map<Long, User> cache = new ConcurrentHashMap<>();

    public CachingUserServiceProxy(UserService target) {
        this.target = target;
    }

    @Override
    public User findById(Long id) {
        return cache.computeIfAbsent(id, target::findById);
    }

    public void evict(Long id) {
        cache.remove(id);
    }
}
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Spring AOP Proxy

```java
// Springì€ @Transactional, @Cacheable ë“±ì„ í”„ë¡ì‹œë¡œ êµ¬í˜„

@Service
public class OrderService {

    @Transactional  // í”„ë¡ì‹œê°€ íŠ¸ëœì­ì…˜ ê´€ë¦¬
    public void createOrder(Order order) {
        // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
    }

    @Cacheable("users")  // í”„ë¡ì‹œê°€ ìºì‹œ ê´€ë¦¬
    public User findUser(Long id) {
        return userRepository.findById(id);
    }
}

// Springì´ ìƒì„±í•˜ëŠ” í”„ë¡ì‹œ (ê°œë…ì )
public class OrderService$$Proxy extends OrderService {

    @Override
    public void createOrder(Order order) {
        TransactionStatus tx = txManager.getTransaction();
        try {
            super.createOrder(order);
            txManager.commit(tx);
        } catch (Exception e) {
            txManager.rollback(tx);
            throw e;
        }
    }
}
```

### JDK Dynamic Proxy

```java
public class LoggingInvocationHandler implements InvocationHandler {
    private final Object target;

    public LoggingInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before: " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("After: " + method.getName());
        return result;
    }
}

// í”„ë¡ì‹œ ìƒì„±
UserService proxy = (UserService) Proxy.newProxyInstance(
    UserService.class.getClassLoader(),
    new Class<?>[] { UserService.class },
    new LoggingInvocationHandler(new UserServiceImpl())
);

proxy.findById(1L);
// Before: findById
// DB ì¡°íšŒ: 1
// After: findById
```

---

# í–‰ë™ íŒ¨í„´ (Behavioral Patterns)

ê°ì²´ ê°„ì˜ ì±…ì„ ë¶„ë°°ì™€ ì•Œê³ ë¦¬ì¦˜ì„ ë‹¤ë£¬ë‹¤.

---

## Strategy (ì „ëµ)

ì•Œê³ ë¦¬ì¦˜ì„ ìº¡ìŠí™”í•˜ì—¬ ëŸ°íƒ€ì„ì— êµì²´í•  ìˆ˜ ìˆê²Œ í•œë‹¤.

### êµ¬í˜„

```java
// 1. Strategy ì¸í„°í˜ì´ìŠ¤
@FunctionalInterface
public interface PaymentStrategy {
    void pay(int amount);
}

// 2. Concrete Strategies
public class CreditCardPayment implements PaymentStrategy {
    private final String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public void pay(int amount) {
        System.out.println(amount + "ì›ì„ ì‹ ìš©ì¹´ë“œë¡œ ê²°ì œ (ì¹´ë“œë²ˆí˜¸: " + cardNumber + ")");
    }
}

public class KakaoPayPayment implements PaymentStrategy {
    private final String phoneNumber;

    public KakaoPayPayment(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    @Override
    public void pay(int amount) {
        System.out.println(amount + "ì›ì„ ì¹´ì¹´ì˜¤í˜ì´ë¡œ ê²°ì œ (ì „í™”ë²ˆí˜¸: " + phoneNumber + ")");
    }
}

public class NaverPayPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println(amount + "ì›ì„ ë„¤ì´ë²„í˜ì´ë¡œ ê²°ì œ");
    }
}

// 3. Context
public class ShoppingCart {
    private final List<Item> items = new ArrayList<>();

    public void addItem(Item item) {
        items.add(item);
    }

    public int calculateTotal() {
        return items.stream()
            .mapToInt(Item::getPrice)
            .sum();
    }

    public void checkout(PaymentStrategy paymentStrategy) {
        int total = calculateTotal();
        paymentStrategy.pay(total);
    }
}

// 4. ì‚¬ìš©
ShoppingCart cart = new ShoppingCart();
cart.addItem(new Item("í‚¤ë³´ë“œ", 50000));
cart.addItem(new Item("ë§ˆìš°ìŠ¤", 30000));

// ê²°ì œ ë°©ì‹ ì„ íƒ
cart.checkout(new CreditCardPayment("1234-5678-9012-3456"));
cart.checkout(new KakaoPayPayment("010-1234-5678"));

// ëŒë‹¤ë¡œ ê°„ë‹¨íˆ
cart.checkout(amount -> System.out.println("í¬ì¸íŠ¸ë¡œ " + amount + "ì› ê²°ì œ"));
```

### ì‹¤ë¬´ ì˜ˆì‹œ: ì •ë ¬ ì „ëµ

```java
public class SortingContext<T> {
    private Comparator<T> strategy;

    public void setStrategy(Comparator<T> strategy) {
        this.strategy = strategy;
    }

    public List<T> sort(List<T> list) {
        List<T> result = new ArrayList<>(list);
        result.sort(strategy);
        return result;
    }
}

// ì‚¬ìš©
List<Product> products = getProducts();
SortingContext<Product> context = new SortingContext<>();

// ê°€ê²©ìˆœ
context.setStrategy(Comparator.comparing(Product::getPrice));
List<Product> byPrice = context.sort(products);

// ì´ë¦„ìˆœ
context.setStrategy(Comparator.comparing(Product::getName));
List<Product> byName = context.sort(products);

// ë³µí•© ì •ë ¬
context.setStrategy(
    Comparator.comparing(Product::getCategory)
              .thenComparing(Product::getPrice)
);
```

### Springì—ì„œì˜ Strategy

```java
// ì¸í„°í˜ì´ìŠ¤ë¡œ ì „ëµ ì •ì˜
public interface DiscountPolicy {
    int calculateDiscount(Order order);
}

@Component("fixedDiscount")
public class FixedDiscountPolicy implements DiscountPolicy {
    @Override
    public int calculateDiscount(Order order) {
        return 1000;
    }
}

@Component("rateDiscount")
public class RateDiscountPolicy implements DiscountPolicy {
    @Override
    public int calculateDiscount(Order order) {
        return order.getTotal() * 10 / 100;
    }
}

// ì „ëµ ì£¼ì…
@Service
public class OrderService {
    private final DiscountPolicy discountPolicy;

    public OrderService(@Qualifier("rateDiscount") DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}

// ë˜ëŠ” Mapìœ¼ë¡œ ëª¨ë“  ì „ëµ ì£¼ì…
@Service
public class OrderService {
    private final Map<String, DiscountPolicy> policies;

    public OrderService(Map<String, DiscountPolicy> policies) {
        this.policies = policies;
    }

    public int discount(String policyName, Order order) {
        return policies.get(policyName).calculateDiscount(order);
    }
}
```

---

## Template Method (í…œí”Œë¦¿ ë©”ì„œë“œ)

ì•Œê³ ë¦¬ì¦˜ì˜ ê³¨ê²©ì„ ì •ì˜í•˜ê³ , ì¼ë¶€ ë‹¨ê³„ë¥¼ ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ êµ¬í˜„í•˜ê²Œ í•œë‹¤.

### êµ¬í˜„

```java
// 1. Abstract Class with Template Method
public abstract class DataParser {

    // í…œí”Œë¦¿ ë©”ì„œë“œ - finalë¡œ ì•Œê³ ë¦¬ì¦˜ ê³¨ê²© ë³´í˜¸
    public final List<Record> parse(String filePath) {
        String rawData = readFile(filePath);
        String cleanedData = cleanData(rawData);
        List<Record> records = parseData(cleanedData);
        records = processRecords(records);  // Hook
        logResult(records);
        return records;
    }

    // ê³µí†µ êµ¬í˜„
    private String readFile(String filePath) {
        System.out.println("íŒŒì¼ ì½ê¸°: " + filePath);
        // íŒŒì¼ ì½ê¸° ë¡œì§
        return "raw data";
    }

    // ì¶”ìƒ ë©”ì„œë“œ - ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ êµ¬í˜„
    protected abstract String cleanData(String rawData);
    protected abstract List<Record> parseData(String data);

    // Hook - ì„ íƒì  ì˜¤ë²„ë¼ì´ë“œ
    protected List<Record> processRecords(List<Record> records) {
        return records;  // ê¸°ë³¸: ì•„ë¬´ê²ƒë„ ì•ˆ í•¨
    }

    // ê³µí†µ êµ¬í˜„
    private void logResult(List<Record> records) {
        System.out.println("ì²˜ë¦¬ ì™„ë£Œ: " + records.size() + "ê±´");
    }
}

// 2. Concrete Classes
public class CsvParser extends DataParser {

    @Override
    protected String cleanData(String rawData) {
        return rawData.trim().replaceAll("\\s+", " ");
    }

    @Override
    protected List<Record> parseData(String data) {
        List<Record> records = new ArrayList<>();
        String[] lines = data.split("\n");
        for (String line : lines) {
            String[] fields = line.split(",");
            records.add(new Record(fields));
        }
        return records;
    }
}

public class JsonParser extends DataParser {

    @Override
    protected String cleanData(String rawData) {
        return rawData.strip();
    }

    @Override
    protected List<Record> parseData(String data) {
        // JSON íŒŒì‹± ë¡œì§
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(data, new TypeReference<>() {});
    }

    @Override
    protected List<Record> processRecords(List<Record> records) {
        // JSON íŠ¹í™” ì²˜ë¦¬
        return records.stream()
            .filter(Record::isValid)
            .collect(Collectors.toList());
    }
}

// 3. ì‚¬ìš©
DataParser csvParser = new CsvParser();
csvParser.parse("data.csv");

DataParser jsonParser = new JsonParser();
jsonParser.parse("data.json");
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Springì˜ JdbcTemplate

```java
// JdbcTemplate ë‚´ë¶€ êµ¬í˜„ (ê°œë…ì )
public abstract class JdbcTemplate {

    public <T> T execute(ConnectionCallback<T> action) {
        Connection con = DataSourceUtils.getConnection(getDataSource());
        try {
            return action.doInConnection(con);  // ì½œë°±
        } catch (SQLException ex) {
            throw translateException(ex);
        } finally {
            DataSourceUtils.releaseConnection(con, getDataSource());
        }
    }

    public <T> T query(String sql, ResultSetExtractor<T> rse) {
        return execute((Connection con) -> {
            try (Statement stmt = con.createStatement();
                 ResultSet rs = stmt.executeQuery(sql)) {
                return rse.extractData(rs);  // ì„œë¸Œí´ë˜ìŠ¤/ì½œë°±ì—ì„œ êµ¬í˜„
            }
        });
    }
}
```

### Strategy vs Template Method

```
Template Method:
- ìƒì† ê¸°ë°˜
- ì•Œê³ ë¦¬ì¦˜ ê³¨ê²© ê³ ì •, ì¼ë¶€ ë‹¨ê³„ë§Œ ë³€ê²½
- ì»´íŒŒì¼ íƒ€ì„ì— ê²°ì •

Strategy:
- êµ¬ì„±(Composition) ê¸°ë°˜
- ì „ì²´ ì•Œê³ ë¦¬ì¦˜ì„ êµì²´
- ëŸ°íƒ€ì„ì— ë³€ê²½ ê°€ëŠ¥
```

---

## Command (ì»¤ë§¨ë“œ)

ìš”ì²­ì„ ê°ì²´ë¡œ ìº¡ìŠí™”í•˜ì—¬ íŒŒë¼ë¯¸í„°í™”, íì‰, ë¡œê¹…, ì·¨ì†Œ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

### êµ¬í˜„

```java
// 1. Command ì¸í„°í˜ì´ìŠ¤
public interface Command {
    void execute();
    void undo();  // ì‹¤í–‰ ì·¨ì†Œ
}

// 2. Receiver
public class TextEditor {
    private StringBuilder content = new StringBuilder();

    public void write(String text) {
        content.append(text);
    }

    public void delete(int length) {
        if (length > content.length()) {
            length = content.length();
        }
        content.delete(content.length() - length, content.length());
    }

    public String getContent() {
        return content.toString();
    }
}

// 3. Concrete Commands
public class WriteCommand implements Command {
    private final TextEditor editor;
    private final String text;

    public WriteCommand(TextEditor editor, String text) {
        this.editor = editor;
        this.text = text;
    }

    @Override
    public void execute() {
        editor.write(text);
    }

    @Override
    public void undo() {
        editor.delete(text.length());
    }
}

public class DeleteCommand implements Command {
    private final TextEditor editor;
    private final int length;
    private String deletedText;

    public DeleteCommand(TextEditor editor, int length) {
        this.editor = editor;
        this.length = length;
    }

    @Override
    public void execute() {
        String content = editor.getContent();
        deletedText = content.substring(
            Math.max(0, content.length() - length)
        );
        editor.delete(length);
    }

    @Override
    public void undo() {
        editor.write(deletedText);
    }
}

// 4. Invoker
public class CommandHistory {
    private final Deque<Command> history = new ArrayDeque<>();
    private final Deque<Command> redoStack = new ArrayDeque<>();

    public void execute(Command command) {
        command.execute();
        history.push(command);
        redoStack.clear();  // ìƒˆ ëª…ë ¹ ì‹¤í–‰ ì‹œ redo ìŠ¤íƒ ì´ˆê¸°í™”
    }

    public void undo() {
        if (!history.isEmpty()) {
            Command command = history.pop();
            command.undo();
            redoStack.push(command);
        }
    }

    public void redo() {
        if (!redoStack.isEmpty()) {
            Command command = redoStack.pop();
            command.execute();
            history.push(command);
        }
    }
}

// 5. ì‚¬ìš©
TextEditor editor = new TextEditor();
CommandHistory history = new CommandHistory();

history.execute(new WriteCommand(editor, "Hello "));
history.execute(new WriteCommand(editor, "World"));
System.out.println(editor.getContent());  // Hello World

history.undo();
System.out.println(editor.getContent());  // Hello

history.redo();
System.out.println(editor.getContent());  // Hello World
```

### ì‹¤ë¬´ ì˜ˆì‹œ: íŠ¸ëœì­ì…˜ ìŠ¤í¬ë¦½íŠ¸

```java
public interface TransactionCommand {
    void execute() throws Exception;
    void rollback();
}

public class CreateOrderCommand implements TransactionCommand {
    private final OrderService orderService;
    private final Order order;
    private Long createdOrderId;

    @Override
    public void execute() throws Exception {
        createdOrderId = orderService.create(order);
    }

    @Override
    public void rollback() {
        if (createdOrderId != null) {
            orderService.delete(createdOrderId);
        }
    }
}

// ì—¬ëŸ¬ ì»¤ë§¨ë“œë¥¼ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ë¬¶ê¸°
public class TransactionExecutor {

    public void executeAll(List<TransactionCommand> commands) {
        List<TransactionCommand> executed = new ArrayList<>();

        try {
            for (TransactionCommand command : commands) {
                command.execute();
                executed.add(command);
            }
        } catch (Exception e) {
            // ì—­ìˆœìœ¼ë¡œ ë¡¤ë°±
            Collections.reverse(executed);
            for (TransactionCommand command : executed) {
                command.rollback();
            }
            throw new RuntimeException("Transaction failed", e);
        }
    }
}
```

---

## Observer (ì˜µì €ë²„)

ê°ì²´ ìƒíƒœê°€ ë³€ê²½ë˜ë©´ ì˜ì¡´ ê°ì²´ë“¤ì—ê²Œ ìë™ìœ¼ë¡œ ì•Œë¦°ë‹¤.

### êµ¬í˜„

```java
// 1. Subject
public interface Subject {
    void attach(Observer observer);
    void detach(Observer observer);
    void notifyObservers();
}

// 2. Observer
public interface Observer {
    void update(String message);
}

// 3. Concrete Subject
public class NewsPublisher implements Subject {
    private final List<Observer> observers = new ArrayList<>();
    private String latestNews;

    @Override
    public void attach(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(latestNews);
        }
    }

    public void publishNews(String news) {
        this.latestNews = news;
        notifyObservers();
    }
}

// 4. Concrete Observers
public class EmailSubscriber implements Observer {
    private final String email;

    public EmailSubscriber(String email) {
        this.email = email;
    }

    @Override
    public void update(String message) {
        System.out.println("ì´ë©”ì¼ ë°œì†¡ to " + email + ": " + message);
    }
}

public class PushSubscriber implements Observer {
    private final String deviceId;

    public PushSubscriber(String deviceId) {
        this.deviceId = deviceId;
    }

    @Override
    public void update(String message) {
        System.out.println("í‘¸ì‹œ ì•Œë¦¼ to " + deviceId + ": " + message);
    }
}

// 5. ì‚¬ìš©
NewsPublisher publisher = new NewsPublisher();

publisher.attach(new EmailSubscriber("user@example.com"));
publisher.attach(new PushSubscriber("device-123"));

publisher.publishNews("ì†ë³´: ìƒˆë¡œìš´ Java ë²„ì „ ì¶œì‹œ!");
```

### Java ë‚´ì¥ ê¸°ëŠ¥ í™œìš©

```java
// PropertyChangeSupport í™œìš©
public class Stock {
    private final PropertyChangeSupport support = new PropertyChangeSupport(this);
    private String symbol;
    private double price;

    public void addPropertyChangeListener(PropertyChangeListener listener) {
        support.addPropertyChangeListener(listener);
    }

    public void removePropertyChangeListener(PropertyChangeListener listener) {
        support.removePropertyChangeListener(listener);
    }

    public void setPrice(double newPrice) {
        double oldPrice = this.price;
        this.price = newPrice;
        support.firePropertyChange("price", oldPrice, newPrice);
    }
}

// ì‚¬ìš©
Stock apple = new Stock("AAPL", 150.0);
apple.addPropertyChangeListener(event -> {
    System.out.println("ì£¼ê°€ ë³€ë™: " + event.getOldValue() + " -> " + event.getNewValue());
});

apple.setPrice(155.0);  // ì£¼ê°€ ë³€ë™: 150.0 -> 155.0
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Spring ApplicationEvent

```java
// 1. ì´ë²¤íŠ¸ ì •ì˜
public class OrderCreatedEvent extends ApplicationEvent {
    private final Order order;

    public OrderCreatedEvent(Object source, Order order) {
        super(source);
        this.order = order;
    }

    public Order getOrder() { return order; }
}

// 2. ì´ë²¤íŠ¸ ë°œí–‰
@Service
public class OrderService {

    @Autowired
    private ApplicationEventPublisher eventPublisher;

    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(new Order(request));
        eventPublisher.publishEvent(new OrderCreatedEvent(this, order));
        return order;
    }
}

// 3. ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
@Component
public class OrderEventListener {

    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        System.out.println("ì£¼ë¬¸ ìƒì„±ë¨: " + event.getOrder().getId());
    }

    @Async
    @EventListener
    public void sendNotification(OrderCreatedEvent event) {
        // ë¹„ë™ê¸° ì•Œë¦¼ ë°œì†¡
        notificationService.send(event.getOrder().getCustomerEmail());
    }
}
```

---

## State (ìƒíƒœ)

ê°ì²´ì˜ ë‚´ë¶€ ìƒíƒœì— ë”°ë¼ í–‰ë™ì„ ë³€ê²½í•œë‹¤. ìƒíƒœë¥¼ ê°ì²´ë¡œ í‘œí˜„í•œë‹¤.

### êµ¬í˜„

```java
// 1. State ì¸í„°í˜ì´ìŠ¤
public interface OrderState {
    void next(Order order);
    void prev(Order order);
    void printStatus();
}

// 2. Concrete States
public class OrderedState implements OrderState {
    @Override
    public void next(Order order) {
        order.setState(new ShippedState());
    }

    @Override
    public void prev(Order order) {
        System.out.println("ì£¼ë¬¸ ìƒíƒœê°€ ê°€ì¥ ì²˜ìŒì…ë‹ˆë‹¤.");
    }

    @Override
    public void printStatus() {
        System.out.println("ì£¼ë¬¸ ì™„ë£Œ - ë°°ì†¡ ì¤€ë¹„ ì¤‘");
    }
}

public class ShippedState implements OrderState {
    @Override
    public void next(Order order) {
        order.setState(new DeliveredState());
    }

    @Override
    public void prev(Order order) {
        order.setState(new OrderedState());
    }

    @Override
    public void printStatus() {
        System.out.println("ë°°ì†¡ ì¤‘");
    }
}

public class DeliveredState implements OrderState {
    @Override
    public void next(Order order) {
        System.out.println("ì´ë¯¸ ë°°ì†¡ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");
    }

    @Override
    public void prev(Order order) {
        order.setState(new ShippedState());
    }

    @Override
    public void printStatus() {
        System.out.println("ë°°ì†¡ ì™„ë£Œ");
    }
}

// 3. Context
public class Order {
    private OrderState state = new OrderedState();

    public void setState(OrderState state) {
        this.state = state;
    }

    public void nextState() {
        state.next(this);
    }

    public void prevState() {
        state.prev(this);
    }

    public void printStatus() {
        state.printStatus();
    }
}

// 4. ì‚¬ìš©
Order order = new Order();
order.printStatus();  // ì£¼ë¬¸ ì™„ë£Œ - ë°°ì†¡ ì¤€ë¹„ ì¤‘

order.nextState();
order.printStatus();  // ë°°ì†¡ ì¤‘

order.nextState();
order.printStatus();  // ë°°ì†¡ ì™„ë£Œ

order.nextState();    // ì´ë¯¸ ë°°ì†¡ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.
```

### State vs Strategy

```
State:
- ìƒíƒœì— ë”°ë¼ í–‰ë™ì´ ìë™ìœ¼ë¡œ ë³€ê²½
- ìƒíƒœ ì „ì´ ë¡œì§ì´ ìƒíƒœ ê°ì²´ ë‚´ë¶€ì— ìˆìŒ
- í´ë¼ì´ì–¸íŠ¸ëŠ” ìƒíƒœ ë³€ê²½ì„ ì§ì ‘ í•˜ì§€ ì•ŠìŒ

Strategy:
- í´ë¼ì´ì–¸íŠ¸ê°€ ì „ëµì„ ì§ì ‘ ì„ íƒ/ë³€ê²½
- ì „ëµ ê°„ ì˜ì¡´ì„± ì—†ìŒ
- ì•Œê³ ë¦¬ì¦˜ ì„ íƒì— ì´ˆì 
```

---

## Chain of Responsibility (ì±…ì„ ì—°ì‡„)

ìš”ì²­ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ê¸°íšŒë¥¼ ì²´ì¸ì˜ ê° ê°ì²´ì—ê²Œ ìˆœì°¨ì ìœ¼ë¡œ ì œê³µí•œë‹¤.

### êµ¬í˜„

```java
// 1. Handler
public abstract class SupportHandler {
    protected SupportHandler nextHandler;

    public void setNext(SupportHandler handler) {
        this.nextHandler = handler;
    }

    public abstract void handle(SupportTicket ticket);
}

// 2. Concrete Handlers
public class Level1Support extends SupportHandler {
    @Override
    public void handle(SupportTicket ticket) {
        if (ticket.getSeverity() == Severity.LOW) {
            System.out.println("Level 1 ì§€ì›íŒ€ì—ì„œ ì²˜ë¦¬: " + ticket.getDescription());
        } else if (nextHandler != null) {
            nextHandler.handle(ticket);
        }
    }
}

public class Level2Support extends SupportHandler {
    @Override
    public void handle(SupportTicket ticket) {
        if (ticket.getSeverity() == Severity.MEDIUM) {
            System.out.println("Level 2 ì§€ì›íŒ€ì—ì„œ ì²˜ë¦¬: " + ticket.getDescription());
        } else if (nextHandler != null) {
            nextHandler.handle(ticket);
        }
    }
}

public class Level3Support extends SupportHandler {
    @Override
    public void handle(SupportTicket ticket) {
        if (ticket.getSeverity() == Severity.HIGH) {
            System.out.println("Level 3 ì§€ì›íŒ€(ì—”ì§€ë‹ˆì–´)ì—ì„œ ì²˜ë¦¬: " + ticket.getDescription());
        } else if (nextHandler != null) {
            nextHandler.handle(ticket);
        } else {
            System.out.println("ì²˜ë¦¬í•  ìˆ˜ ì—†ëŠ” í‹°ì¼“: " + ticket.getDescription());
        }
    }
}

// 3. ì²´ì¸ êµ¬ì„± ë° ì‚¬ìš©
SupportHandler level1 = new Level1Support();
SupportHandler level2 = new Level2Support();
SupportHandler level3 = new Level3Support();

level1.setNext(level2);
level2.setNext(level3);

// ìš”ì²­ ì²˜ë¦¬
level1.handle(new SupportTicket("ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •", Severity.LOW));
// Level 1 ì§€ì›íŒ€ì—ì„œ ì²˜ë¦¬: ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •

level1.handle(new SupportTicket("ê²°ì œ ì˜¤ë¥˜", Severity.MEDIUM));
// Level 2 ì§€ì›íŒ€ì—ì„œ ì²˜ë¦¬: ê²°ì œ ì˜¤ë¥˜

level1.handle(new SupportTicket("ì‹œìŠ¤í…œ ì¥ì• ", Severity.HIGH));
// Level 3 ì§€ì›íŒ€(ì—”ì§€ë‹ˆì–´)ì—ì„œ ì²˜ë¦¬: ì‹œìŠ¤í…œ ì¥ì• 
```

### ì‹¤ë¬´ ì˜ˆì‹œ: Servlet Filter

```java
public class LoggingFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request,
                         ServletResponse response,
                         FilterChain chain) throws IOException, ServletException {
        System.out.println("Request ë¡œê¹…");
        chain.doFilter(request, response);  // ë‹¤ìŒ í•¸ë“¤ëŸ¬ë¡œ
        System.out.println("Response ë¡œê¹…");
    }
}

public class AuthenticationFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request,
                         ServletResponse response,
                         FilterChain chain) throws IOException, ServletException {
        if (isAuthenticated(request)) {
            chain.doFilter(request, response);
        } else {
            ((HttpServletResponse) response).sendError(401);
        }
    }
}
```

---

## Mediator (ì¤‘ì¬ì)

ê°ì²´ë“¤ ê°„ì˜ ìƒí˜¸ì‘ìš©ì„ ìº¡ìŠí™”í•˜ì—¬ ê°ì²´ë“¤ì´ ì„œë¡œë¥¼ ì§ì ‘ ì°¸ì¡°í•˜ì§€ ì•Šê²Œ í•œë‹¤.

### êµ¬í˜„

```java
// 1. Mediator
public interface ChatMediator {
    void sendMessage(String message, User sender);
    void addUser(User user);
}

// 2. Concrete Mediator
public class ChatRoom implements ChatMediator {
    private final List<User> users = new ArrayList<>();

    @Override
    public void addUser(User user) {
        users.add(user);
    }

    @Override
    public void sendMessage(String message, User sender) {
        for (User user : users) {
            // ë°œì‹ ì ì œì™¸í•˜ê³  ë©”ì‹œì§€ ì „ë‹¬
            if (user != sender) {
                user.receive(message, sender.getName());
            }
        }
    }
}

// 3. Colleague
public abstract class User {
    protected ChatMediator mediator;
    protected String name;

    public User(ChatMediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
    }

    public String getName() { return name; }

    public abstract void send(String message);
    public abstract void receive(String message, String from);
}

// 4. Concrete Colleagues
public class ChatUser extends User {
    public ChatUser(ChatMediator mediator, String name) {
        super(mediator, name);
    }

    @Override
    public void send(String message) {
        System.out.println(name + " ì „ì†¡: " + message);
        mediator.sendMessage(message, this);
    }

    @Override
    public void receive(String message, String from) {
        System.out.println(name + " ìˆ˜ì‹  [" + from + "]: " + message);
    }
}

// 5. ì‚¬ìš©
ChatMediator chatRoom = new ChatRoom();

User alice = new ChatUser(chatRoom, "Alice");
User bob = new ChatUser(chatRoom, "Bob");
User charlie = new ChatUser(chatRoom, "Charlie");

chatRoom.addUser(alice);
chatRoom.addUser(bob);
chatRoom.addUser(charlie);

alice.send("ì•ˆë…•í•˜ì„¸ìš”!");
// Alice ì „ì†¡: ì•ˆë…•í•˜ì„¸ìš”!
// Bob ìˆ˜ì‹  [Alice]: ì•ˆë…•í•˜ì„¸ìš”!
// Charlie ìˆ˜ì‹  [Alice]: ì•ˆë…•í•˜ì„¸ìš”!
```

---

## Memento (ë©”ë©˜í† )

ê°ì²´ì˜ ìƒíƒœë¥¼ ì €ì¥í•˜ê³  ë³µì›í•  ìˆ˜ ìˆê²Œ í•œë‹¤.

### êµ¬í˜„

```java
// 1. Memento
public class EditorMemento {
    private final String content;
    private final int cursorPosition;
    private final LocalDateTime savedAt;

    public EditorMemento(String content, int cursorPosition) {
        this.content = content;
        this.cursorPosition = cursorPosition;
        this.savedAt = LocalDateTime.now();
    }

    // Package-private: Originatorë§Œ ì ‘ê·¼ ê°€ëŠ¥
    String getContent() { return content; }
    int getCursorPosition() { return cursorPosition; }

    // Public: í‘œì‹œìš©
    public LocalDateTime getSavedAt() { return savedAt; }
}

// 2. Originator
public class TextEditor {
    private String content = "";
    private int cursorPosition = 0;

    public void write(String text) {
        content = content.substring(0, cursorPosition)
                  + text
                  + content.substring(cursorPosition);
        cursorPosition += text.length();
    }

    public EditorMemento save() {
        return new EditorMemento(content, cursorPosition);
    }

    public void restore(EditorMemento memento) {
        this.content = memento.getContent();
        this.cursorPosition = memento.getCursorPosition();
    }

    public String getContent() { return content; }
}

// 3. Caretaker
public class EditorHistory {
    private final Deque<EditorMemento> history = new ArrayDeque<>();
    private static final int MAX_HISTORY = 50;

    public void save(EditorMemento memento) {
        if (history.size() >= MAX_HISTORY) {
            history.removeLast();
        }
        history.push(memento);
    }

    public EditorMemento undo() {
        if (history.isEmpty()) {
            return null;
        }
        return history.pop();
    }

    public List<EditorMemento> getHistory() {
        return new ArrayList<>(history);
    }
}

// 4. ì‚¬ìš©
TextEditor editor = new TextEditor();
EditorHistory history = new EditorHistory();

editor.write("Hello");
history.save(editor.save());

editor.write(" World");
history.save(editor.save());

editor.write("!");
System.out.println(editor.getContent());  // Hello World!

// Undo
EditorMemento previous = history.undo();
editor.restore(previous);
System.out.println(editor.getContent());  // Hello World
```

---

## Iterator (ë°˜ë³µì)

ì»¬ë ‰ì…˜ì˜ ë‚´ë¶€ êµ¬ì¡°ë¥¼ ë…¸ì¶œí•˜ì§€ ì•Šê³  ìš”ì†Œì— ìˆœì°¨ì ìœ¼ë¡œ ì ‘ê·¼í•œë‹¤.

### êµ¬í˜„

```java
// 1. Iterator ì¸í„°í˜ì´ìŠ¤
public interface Iterator<T> {
    boolean hasNext();
    T next();
}

// 2. Aggregate
public interface IterableCollection<T> {
    Iterator<T> createIterator();
}

// 3. Concrete Iterator
public class BookIterator implements Iterator<Book> {
    private final List<Book> books;
    private int position = 0;

    public BookIterator(List<Book> books) {
        this.books = books;
    }

    @Override
    public boolean hasNext() {
        return position < books.size();
    }

    @Override
    public Book next() {
        return books.get(position++);
    }
}

// 4. Concrete Aggregate
public class BookShelf implements IterableCollection<Book> {
    private final List<Book> books = new ArrayList<>();

    public void addBook(Book book) {
        books.add(book);
    }

    @Override
    public Iterator<Book> createIterator() {
        return new BookIterator(books);
    }

    // íŠ¹ìˆ˜ ì´í„°ë ˆì´í„°
    public Iterator<Book> createReverseIterator() {
        return new Iterator<>() {
            private int position = books.size() - 1;

            @Override
            public boolean hasNext() { return position >= 0; }

            @Override
            public Book next() { return books.get(position--); }
        };
    }
}

// 5. ì‚¬ìš©
BookShelf shelf = new BookShelf();
shelf.addBook(new Book("Design Patterns"));
shelf.addBook(new Book("Clean Code"));
shelf.addBook(new Book("Effective Java"));

Iterator<Book> it = shelf.createIterator();
while (it.hasNext()) {
    System.out.println(it.next().getTitle());
}
```

---

## Visitor (ë°©ë¬¸ì)

ê°ì²´ êµ¬ì¡°ë¥¼ ë³€ê²½í•˜ì§€ ì•Šê³  ìƒˆë¡œìš´ ì—°ì‚°ì„ ì¶”ê°€í•œë‹¤.

### êµ¬í˜„

```java
// 1. Element
public interface DocumentElement {
    void accept(DocumentVisitor visitor);
}

// 2. Concrete Elements
public class Paragraph implements DocumentElement {
    private final String text;

    public Paragraph(String text) { this.text = text; }
    public String getText() { return text; }

    @Override
    public void accept(DocumentVisitor visitor) {
        visitor.visit(this);
    }
}

public class Image implements DocumentElement {
    private final String url;
    private final int width;
    private final int height;

    public Image(String url, int width, int height) {
        this.url = url;
        this.width = width;
        this.height = height;
    }

    // Getters...

    @Override
    public void accept(DocumentVisitor visitor) {
        visitor.visit(this);
    }
}

public class Table implements DocumentElement {
    private final List<List<String>> data;

    public Table(List<List<String>> data) { this.data = data; }
    public List<List<String>> getData() { return data; }

    @Override
    public void accept(DocumentVisitor visitor) {
        visitor.visit(this);
    }
}

// 3. Visitor
public interface DocumentVisitor {
    void visit(Paragraph paragraph);
    void visit(Image image);
    void visit(Table table);
}

// 4. Concrete Visitors
public class HtmlExportVisitor implements DocumentVisitor {
    private final StringBuilder html = new StringBuilder();

    @Override
    public void visit(Paragraph paragraph) {
        html.append("<p>").append(paragraph.getText()).append("</p>\n");
    }

    @Override
    public void visit(Image image) {
        html.append(String.format("<img src=\"%s\" width=\"%d\" height=\"%d\" />\n",
            image.getUrl(), image.getWidth(), image.getHeight()));
    }

    @Override
    public void visit(Table table) {
        html.append("<table>\n");
        for (List<String> row : table.getData()) {
            html.append("  <tr>");
            for (String cell : row) {
                html.append("<td>").append(cell).append("</td>");
            }
            html.append("</tr>\n");
        }
        html.append("</table>\n");
    }

    public String getResult() { return html.toString(); }
}

public class MarkdownExportVisitor implements DocumentVisitor {
    private final StringBuilder markdown = new StringBuilder();

    @Override
    public void visit(Paragraph paragraph) {
        markdown.append(paragraph.getText()).append("\n\n");
    }

    @Override
    public void visit(Image image) {
        markdown.append(String.format("![image](%s)\n\n", image.getUrl()));
    }

    @Override
    public void visit(Table table) {
        // Markdown í…Œì´ë¸” í˜•ì‹ìœ¼ë¡œ ì¶œë ¥
    }

    public String getResult() { return markdown.toString(); }
}

// 5. ì‚¬ìš©
List<DocumentElement> document = List.of(
    new Paragraph("ì œëª©ì…ë‹ˆë‹¤"),
    new Image("logo.png", 100, 50),
    new Table(List.of(
        List.of("ì´ë¦„", "ë‚˜ì´"),
        List.of("í™ê¸¸ë™", "30")
    ))
);

HtmlExportVisitor htmlVisitor = new HtmlExportVisitor();
for (DocumentElement element : document) {
    element.accept(htmlVisitor);
}
System.out.println(htmlVisitor.getResult());
```

---

## Interpreter (ì¸í„°í”„ë¦¬í„°)

ì–¸ì–´ì˜ ë¬¸ë²•ì„ í´ë˜ìŠ¤ë¡œ í‘œí˜„í•˜ê³  í•´ì„í•œë‹¤.

### êµ¬í˜„

```java
// ê°„ë‹¨í•œ ìˆ˜ì‹ ì¸í„°í”„ë¦¬í„°
public interface Expression {
    int interpret();
}

public class NumberExpression implements Expression {
    private final int number;

    public NumberExpression(int number) {
        this.number = number;
    }

    @Override
    public int interpret() {
        return number;
    }
}

public class AddExpression implements Expression {
    private final Expression left;
    private final Expression right;

    public AddExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public int interpret() {
        return left.interpret() + right.interpret();
    }
}

public class MultiplyExpression implements Expression {
    private final Expression left;
    private final Expression right;

    public MultiplyExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public int interpret() {
        return left.interpret() * right.interpret();
    }
}

// íŒŒì„œ
public class ExpressionParser {
    public Expression parse(String expression) {
        // "(3 + 5) * 2" -> MultiplyExpression(AddExpression(3, 5), 2)
        // ì‹¤ì œë¡œëŠ” í† í°í™”, AST êµ¬ì¶• í•„ìš”
        return null;
    }
}

// ì‚¬ìš©: (3 + 5) * 2 = 16
Expression expr = new MultiplyExpression(
    new AddExpression(
        new NumberExpression(3),
        new NumberExpression(5)
    ),
    new NumberExpression(2)
);

System.out.println(expr.interpret());  // 16
```

---

# íŒ¨í„´ ì„ íƒ ê°€ì´ë“œ

## íŒ¨í„´ë³„ ì‚¬ìš© ì‹œì 

| ë¬¸ì œ ìƒí™© | ì¶”ì²œ íŒ¨í„´ |
|----------|----------|
| ê°ì²´ê°€ í•˜ë‚˜ë§Œ í•„ìš” | Singleton |
| ë³µì¡í•œ ê°ì²´ ìƒì„± | Builder |
| ê°ì²´ ìƒì„±ì„ ì„œë¸Œí´ë˜ìŠ¤ì— ìœ„ì„ | Factory Method |
| ê´€ë ¨ ê°ì²´êµ° ìƒì„± | Abstract Factory |
| ê¸°ì¡´ ê°ì²´ ë³µì œ | Prototype |
| ì¸í„°í˜ì´ìŠ¤ ë³€í™˜ | Adapter |
| êµ¬í˜„ê³¼ ì¶”ìƒ ë¶„ë¦¬ | Bridge |
| íŠ¸ë¦¬ êµ¬ì¡° | Composite |
| ë™ì  ê¸°ëŠ¥ ì¶”ê°€ | Decorator |
| ë³µì¡í•œ ì„œë¸Œì‹œìŠ¤í…œ ë‹¨ìˆœí™” | Facade |
| ë©”ëª¨ë¦¬ ì ˆì•½ (ê³µìœ ) | Flyweight |
| ì ‘ê·¼ ì œì–´, ì§€ì—° ë¡œë”© | Proxy |
| ì•Œê³ ë¦¬ì¦˜ êµì²´ | Strategy |
| ì•Œê³ ë¦¬ì¦˜ ê³¨ê²© ì •ì˜ | Template Method |
| ìš”ì²­ì„ ê°ì²´ë¡œ | Command |
| ìƒíƒœ ë³€ê²½ ì•Œë¦¼ | Observer |
| ìƒíƒœì— ë”°ë¥¸ í–‰ë™ ë³€ê²½ | State |
| ìš”ì²­ ì²˜ë¦¬ ì²´ì¸ | Chain of Responsibility |
| ê°ì²´ ê°„ í†µì‹  ì¤‘ì•™í™” | Mediator |
| ìƒíƒœ ì €ì¥/ë³µì› | Memento |
| ìˆœíšŒ ì¶”ìƒí™” | Iterator |
| ì—°ì‚° ì¶”ê°€ (êµ¬ì¡° ë³€ê²½ ì—†ì´) | Visitor |
| DSL, ë¬¸ë²• í•´ì„ | Interpreter |

## íŒ¨í„´ ì¡°í•©

```
ìì£¼ í•¨ê»˜ ì‚¬ìš©ë˜ëŠ” íŒ¨í„´:

Factory + Singleton: íŒ©í† ë¦¬ë¥¼ ì‹±ê¸€í„´ìœ¼ë¡œ
Abstract Factory + Factory Method: íŒ©í† ë¦¬ ë©”ì„œë“œë¡œ ì œí’ˆ ìƒì„±
Builder + Fluent Interface: ë©”ì„œë“œ ì²´ì´ë‹
Composite + Iterator: íŠ¸ë¦¬ ìˆœíšŒ
Decorator + Strategy: ë™ì  ì•Œê³ ë¦¬ì¦˜ ì ìš©
Observer + Mediator: ì´ë²¤íŠ¸ ì¤‘ì•™ ê´€ë¦¬
Command + Memento: Undo/Redo êµ¬í˜„
State + Strategy: ìƒíƒœë³„ ì „ëµ
```

---

## ì •ë¦¬

ë””ìì¸ íŒ¨í„´ì€ ë„êµ¬ë‹¤. ëª¨ë“  ìƒí™©ì— íŒ¨í„´ì„ ì ìš©í•˜ë ¤ í•˜ì§€ ë§ê³ , ë¬¸ì œê°€ ìˆì„ ë•Œ ì ì ˆí•œ íŒ¨í„´ì„ ì„ íƒí•´ì•¼ í•œë‹¤.

```
íŒ¨í„´ ì‚¬ìš© ì›ì¹™:

1. ë¬¸ì œ ë¨¼ì €, íŒ¨í„´ì€ ê·¸ ë‹¤ìŒ
2. ë‹¨ìˆœí•œ í•´ê²°ì±…ì´ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì‚¬ìš©
3. íŒ¨í„´ì€ ì˜ì‚¬ì†Œí†µ ë„êµ¬
4. íŒ¨í„´ì„ ìœ„í•œ íŒ¨í„´ì€ ê¸ˆë¬¼
5. SOLID ì›ì¹™ê³¼ í•¨ê»˜ ì ìš©
```

> "Design patterns should be used with caution. Don't use a pattern just because it exists."
> â€” Gang of Four
