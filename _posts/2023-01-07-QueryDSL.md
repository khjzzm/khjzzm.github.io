---
layout: post
title: QueryDSL
---

## Querydsl 소개

스프링부트 + 스프링 데이터 JPA But 복잡한 쿼리, 동적 쿼리 Querydsl 쿼리를 자바 코드로 작성, 문법 오류를 컴파일 시점에!

## 기본 문법

### 시작 - JPQL vs Querydsl
~~~java
//JPQL
@Test
public void startJPQL(){
    String qlString=
        "select m from Member m "+
        "where m.username = :username";
    
    Member findMember=em.createQuery(qlString,Member.class)
        .setParameter("username","member1")
        .getSingleResult();
    
    assertThat(findMember.getUsername()).isEqualTo("member1");
}

//Querydsl
@Test
public void startQuerydsl() {
    JPAQueryFactory queryFactory = new JPAQueryFactory(em);
    QMember m = new QMember("m");
   
    Member findMember = queryFactory
        .select(m)
        .from(m)
        .where(m.username.eq("member1"))//파라미터 바인딩 처리
        .fetchOne();
    assertThat(findMember.getUsername()).isEqualTo("member1");
}
~~~

JPAQueryFactory를 필드로 제공하면 동시성 문제는 어떻게 될까? 
동시성 문제는 JPAQueryFactory를 생성할 때 제공하는 EntityManager(em)에 달려있다. 
스프링 프레임워크는 여러 쓰레드에서 동시에 같은 EntityManager에 접근해도, 
트랜잭션 마다 별도의 영속성 컨텍스트를 제공하기 때문에, 동시성 문제는 걱정하지 않아도 된다.


### 기본 Q-Type 활용
Q클래스 인스턴스를 사용하는 2가지 방법
~~~ java
QMember qMember = new QMember("m"); //별칭 직접 지정 
QMember qMember = QMember.member; //기본 인스턴스 사용
~~~

기본 인스턴스를 static import와 함께 사용
~~~java
import static study.querydsl.entity.QMember.*;
~~~

### 검색 조건 쿼리
JPQL이 제공하는 모든 검색 조건 제공
~~~java
member.username.eq("member1") // username = 'member1'
member.username.ne("member1") //username != 'member1'
member.username.eq("member1").not() // username != 'member1'
member.username.isNotNull() //이름이 is not null
member.age.in(10, 20) // age in (10,20)
member.age.notIn(10, 20) // age not in (10, 20)
member.age.between(10,30) //between 10, 30
member.age.goe(30) // age >= 30
member.age.gt(30) // age > 30
member.age.loe(30) // age <= 30
member.age.lt(30) // age < 30
member.username.like("member%") //like 검색
member.username.contains("member") // like ‘%member%’ 검색 
member.username.startsWith("member") //like ‘member%’ 검색
~~~

AND 조건을 파라미터로 처리
~~~java
@Test
public void searchAndParam() {
  List<Member> result1 = queryFactory
          .selectFrom(member)
          .where(member.username.eq("member1"),
                  member.age.eq(10))
          .fetch();
  assertThat(result1.size()).isEqualTo(1);
}
~~~
where() 에 파라미터로 검색조건을 추가하면 AND 조건이 추가됨   
이경우 null 값은무시 메서드추출을활용해서동적쿼리를깔끔하게만들수있음 뒤에서설명


### 결과조회
- fetch() : 리스트 조회, 데이터 없으면 빈 리스트 반환 
- fetchOne() : 단 건 조회
  - 결과가 없으면 : null
  - 결과가 둘 이상이면 : com.querydsl.core.NonUniqueResultException
- fetchFirst() : limit(1).fetchOne()
- fetchResults() : 페이징 정보 포함, total count 쿼리 추가 실행 
- fetchCount() : count 쿼리로 변경해서 count 수 조회

~~~java
//List
List<Member> fetch = queryFactory
        .selectFrom(member)
        .fetch();

//단 건
Member findMember1 = queryFactory
        .selectFrom(member)
        .fetchOne();

//처음 한 건 조회
Member findMember2 = queryFactory
        .selectFrom(member)
        .fetchFirst();

//페이징에서 사용
QueryResults<Member> results = queryFactory
        .selectFrom(member)
        .fetchResults();

//count 쿼리로 변경
long count = queryFactory
        .selectFrom(member)
        .fetchCount();

~~~

### 정렬
~~~java
List<Member> result = queryFactory
        .selectFrom(member)
        .where(member.age.eq(100))
        .orderBy(member.age.desc(), member.username.asc().nullsLast())
        .fetch();
~~~
desc() , asc() : 일반 정렬  
nullsLast() , nullsFirst() : null 데이터 순서 부여

### 페이징
~~~java
@Test
public void paging1() {
    List<Member> result = queryFactory
        .selectFrom(member)
        .orderBy(member.username.desc())
        .offset(1) //0부터 시작(zero index)
        .limit(2) //최대 2건 조회
        .fetch();
    assertThat(result.size()).isEqualTo(2);
}
~~~

전체 조회 수가 필요하면?
~~~java
@Test
public void paging2() {
  QueryResults<Member> queryResults = queryFactory
          .selectFrom(member)
          .orderBy(member.username.desc())
          .offset(1)
          .limit(2)
          .fetchResults();
  assertThat(queryResults.getTotal()).isEqualTo(4);
  assertThat(queryResults.getLimit()).isEqualTo(2);
  assertThat(queryResults.getOffset()).isEqualTo(1);
  assertThat(queryResults.getResults().size()).isEqualTo(2);
}
~~~
count 쿼리가 실행되니 성능상 주의!   

실무에서 페이징 쿼리를 작성할 때, 데이터를 조회하는 쿼리는 여러 테이블을 조인해야 하지만,
count 쿼리는 조인이 필요 없는 경우도 있다.
그런데 이렇게 자동화된 count 쿼리는 원본 쿼리와 같이 모두 조인을 해버리기 때문에 성능이 안나올 수 있다. 
count 쿼리에 조인이 필요없는 성능 최적화가 필요하다면, count 전용 쿼리를 별도로 작성해야 한다.

### 집합 함수
~~~java
@Test
public void aggregation() throws Exception {
  List<Tuple> result = queryFactory
          .select(member.count(),
                  member.age.sum(),
                  member.age.avg(),
                  member.age.max(),
                  member.age.min())
          .from(member)
          .fetch();
  Tuple tuple = result.get(0);
  assertThat(tuple.get(member.count())).isEqualTo(4);
  assertThat(tuple.get(member.age.sum())).isEqualTo(100);
  assertThat(tuple.get(member.age.avg())).isEqualTo(25);
  assertThat(tuple.get(member.age.max())).isEqualTo(40);
  assertThat(tuple.get(member.age.min())).isEqualTo(10);
}
~~~
JPQL이 제공하는 모든 집합 함수를 제공한다.    
tuple은 프로젝션과 결과반환에서 설명한다.

### GroupBy 사용
~~~java
@Test
public void group() throws Exception {
  List<Tuple> result = queryFactory
          .select(team.name, member.age.avg())
          .from(member)
          .join(member.team, team)
          .groupBy(team.name)
          .fetch();
  Tuple teamA = result.get(0);
  Tuple teamB = result.get(1);
  assertThat(teamA.get(team.name)).isEqualTo("teamA");
  assertThat(teamA.get(member.age.avg())).isEqualTo(15);
  assertThat(teamB.get(team.name)).isEqualTo("teamB");
  assertThat(teamB.get(member.age.avg())).isEqualTo(35);
}
~~~
groupBy , 그룹화된 결과를 제한하려면 having 

groupBy(), having() 예시
~~~java
...
    .groupBy(item.price)
    .having(item.price.gt(1000))
...
~~~

### 조인
**기본 조인**
조인의 기본 문법은 첫 번째 파라미터에 조인 대상을 지정하고, 두 번째 파라미터에 별칭(alias)으로 사용할 Q 타입을 지정하면 된다.

~~~java
@Test
public void join() throws Exception {
  QMember member = QMember.member;
  QTeam team = QTeam.team;
  List<Member> result = queryFactory
          .selectFrom(member)
          .join(member.team, team)
          .where(team.name.eq("teamA"))
          .fetch();
  assertThat(result)
          .extracting("username")
          .containsExactly("member1", "member2");
}
~~~
- join() , innerJoin() : 내부 조인(inner join)
- leftJoin() : left 외부 조인(left outer join)
- rightJoin() : rigth 외부 조인(rigth outer join)
- JPQL의 on과 성능 최적화를 위한 fetch 조인 제공

**세타조인** 연관관계가 없는 필드로 조인
- from 절에 여러 엔티티를 선택해서 세타 조인
- 외부조인불가능

### 조인 - on
ON절을 활용한 조인(JPA 2.1부터 지원) 
1. 조인 대상 필터링
2. 연관관계 없는 엔티티 외부 조인

on 절을 활용해 조인 대상을 필터링 할 때, 외부조인이 아니라 내부조인(inner join)을 사용하면,
where 절에서 필터링 하는 것과 기능이 동일하다. 따라서 on 절을 활용한 조인 대상 필터링을 사용할 때, 
내부조인 이면 익숙한 where 절로 해결하고, 정말 외부조인이 필요한 경우에만 이 기능을 사용하자.

## 중급 문법

## 실무활용 - 순수 JPQ와 Querydll

## 실무활용 스프링 데이터 JPA와 Querydsl

## 스프링데이터 JPA가 제공하는 Querydls 기능