---
layout: post
category: book
title: 일관성 있는 웹 서비스 인터페이스 설계를 위한 REST API 디자인 규칙
---


## 1. REST 소개
### 1.1 Hello World Wild Web
웹은 스위스 제네바의 유럽입자물리연구소CERN 산하 ‘데이터 수집과 제어’ 그룹에 근무하던 컴퓨터 프로그래머가 새로운 소프트웨어 프로젝트를 진행하기 위해 낸 기발한 아이디어에서 시작되었다.

1990년 12월, 지식을 쉽게 공유하고자 월드와이드웹WorldWideWeb01이라는 비영리 소프트웨어 프로젝트를 시작한 팀 버너스리Tim Berners-Lee는 약 1년간 작업한 후 다 음과 같은 내용을 고안하고 구현했다.

- URIUniform Resource Identifier : 모든 웹 도큐먼트에 할당된 유일한 주소
- HTTPHyper Text Transfer Protocol : 인터넷을 통해 컴퓨터가 통신하기 위한 메시지 기반 언어
- HTMLHyper Text Mark-up Language : 정보를 제공하는 도큐먼트를 표현하기 위한 하이퍼텍스트 마크업 언어. 도큐먼트는 관련된 다른 도큐먼트에 대한 링크를/ 포함할 수 있음
- 최초의 웹 서버
- WorldWideWeb과 Nexus : 버너스리는 최초의 웹 브라우저를 ‘WorldWideWeb’ 이라 불렀으나 이후에 웹 자체와의 혼동을 피하기 위해 Nexus라고 이름 붙임
- 웹 브라우저에 탑재된 최초의 위지윅(WYSIWYG)04 HTML 에디터


1991년 8월 6일, 버너스리는 최초의 웹 페이지에 다음과 같이 썼다.
>WorldWideWeb(W3)은 전 세계에 있는 모든 도큐먼트에 접근하는 것을 목표로 하는 광범위한 하이퍼미디어 정보검색의 시작이다.


### 1.2 웹 아키텍쳐
1993년 말에 공동으로 ‘아파치 HTTP 서버 프로젝트’를 시작한 로이 필딩은 웹 확장성에 관심이 있었다.
필딩은 제약점들을 여섯 가지 범주로 묶어 **웹의 구조적 스타일(Web’s architectural style)** 이라고 불렀다. 언급한 웹의 구조적 스타일은 다음과 같다.

1. 클라이언트/서버 Client/Server
2. 균일한 인터페이스 Uniform Interface
3. 계층 시스템 Layered System
4. 캐시 Cache
5. 상태 없음 Stateless
6. 주문형 코드 Code-on-demand

**클라이언트/서버**
웹은 클라이언트/서버 기반 시스템으로, 클라이언트/서버 규약의 핵심 사항은 관 심사의 분리다. 그래서 시스템 내에서 클라이언트와 서버의 역활은 분명하게 나뉜 다. 웹의 일관된 인터페이스를 따른다는 전제하에, 클라이언트와 서버는 각자의 언 어 및 기술을 사용하여 독립적으로 구현되고 배포될 수 있다.

**균일한 인터페이스**
웹을 구성하는 클라이언트, 서버, 네트워크 등의 매체 간 인터페이스는 각 인터페 이스의 일관성에 기반한다. 이러한 웹 컴포넌트들 중 하나라도 기존에 구축된 표준 에서 벗어나면, 웹 커뮤니케이션 체계는 붕괴된다.
웹 컴포넌트들은 필딩이 구분한 다음 네 가지의 인터페이스 제약에 따라 서로 일관 성 있게 상호 운영된다.
1. 리소스 식별
2. 표현을 통한 리소스 처리
3. 자기-서술적 메시지Self-descriptive messages
4. 애플리케이션 상태 엔진으로서의 하이퍼미디어(HATEOAS07)

**계층 시스템**
계층 시스템이라는 제약조건은 프락시 또는 게이트웨이 같은 네트워크 기반의 중 간매체를 사용할 수 있게 한다. 웹의 일관된 인터페이스를 사용하면 중간매체를 클 라이언트와 서버 사이에 마치 없는 것처럼 배치할 수 있다.
일반적으로 네트워크 기반의 중간매체는 특별한 목적을 위해 클라이언트와 서버 간 통신을 가로챌 수 있다. 네트워크 기반의 중간매체는 보통 보안을 강화하거나, 응답을 캐싱하거나, 부하를 분산하는 용도로 사용한다.

**캐시**
캐시는 웹 구조의 중요 제약조건 중 하나다. 캐시라는 제약조건에 의해 웹 서버가 응답 데이터마다 캐시 여부를 선언한다. 캐싱 응답 데이터는 클라이언트가 느끼는 지연을 감소시키고 애플리케이션의 전체적인 이용 가능성과 안정성을 향상시키 며, 웹 서버의 부하를 제어한다. 다시 말해, 캐싱08은 웹의 전체적인 비용을 낮출 수 있는 중요한 방법이다. 캐시는 클라이언트와 서버 사이의 네트워크 경로라면 어디 에라도 위치할 수 있다. 웹 서버단, 콘텐츠 전송망CDN단, 또는 클라이언트 내에도 가능하다.

**상태 없음**
상태 없음 제약조건은 웹 서버가 클라이언트의 상태를 관리할 필요가 없다는 의미 다. 따라서 각 클라이언트는 웹 서버와 상호작용하는 관련 상황 정보를 직접 관리 해야 한다. 웹 서버는 웹 애플리케이션과의 복잡한 커뮤니케이션을 위해 필요한 상 태 관리를 클라이언트에 맡김으로써 더 많은 클라이언트에 서비스할 수 있다. 이러 한 트레이드오프는 웹 구조적인 스타일의 확장성에 이바지하는 주요 요소다.

**주문형 코드**
웹은 주문형 코드(Code-On-Demand)를 아주 많이 사용한다. 이 제약조건은 스크립트나 플러그인 같은 실행 가능한 프로그램을 일시적으로 클라이언트에 전송하여, 클라 이언트가 실행할 수 있도록 한다.
주문형 코드는 웹 서버와 클라이언트 사이에 기술적 결합을 만들어내기도 하는데, 클라이언트는 필요할 때마다 서버에서 내려받은 실행 코드를 이해해야 하기 때문 이다. 이러한 이유로 주문형 코드는 웹의 구조적 스타일에서 유일한 선택사항이다. 주문형 코드 제약사항의 예로 자바 애플릿, 자바스크립트, 플래시 같은 웹 브라우 저 기반의 기술들이 있다.


### 1.3 웹표준
필딩은 팀 버너스리를 비롯한 다른 개발자들과 함께 웹 확장성을 높이는 작업 을 했다. 이런 작업을 통해 표준 설계안을 만들었고, HTTP의 새로운 버전인 HTTP/1.1 스펙을 작성하였다. 또한, URI 문법 형식도 (RFC 3986)으로 규정하 였다. 이렇게 정리된 표준은 웹을 통해 급속히 확산되었고, 웹이 지속적으로 성장하 는 기틀을 마련했다.

### 1.4 REST
필딩은 자신의 박사학위 논문에 서 ‘웹의 구조적 스타일’이라고 이름 붙인 이 문제에 대해 설명하였다. 필딩이 ‘Representational State Transfer(표현 상태 전이, REST)’이라는 이름을 붙인, 웹의 구조적 스타일에 대한 설명은 제약조건들로 이루어져 있다.

### 1.5 REST API
웹 서비스는 특정한 목적을 위해 만들어진 웹 서버로, 다른 사이트나 다른 애플리 케이션이 필요로 하는 것을 제공한다. 클라이언트 프로그램은 웹 서버에서 제공하 는 API를 이용하여 웹 서비스와 통신한다. 보통 API는 데이터와 기능의 집합을 제 공하여 컴퓨터 프로그램 간 상호작용을 촉진하며, 서로 정보를 교환할 수 있게 해 준다.
REST API를 제공하는 웹 서비스를 ‘RESTful’하다고 할 수 있다. REST API는 상 호 연결된 리소스의 결합체며, 이 리소스 집합을 일컬어 REST API의 리소스 모델 이라고 한다.

### 1.6 REST API 설계
EST API 설계의 몇 가지 모범 사례는 HTTP 표준에 포함되어 있지만, 지난 몇 년 동안 표준과 같은 몇 가지 접근 방법이 새롭게 부각되었다. 여전히 우리는 다음과 같은 질문들에 대한 답을 찾아야 한다.
- URI 경로path 세그먼트는 언제 복수로 써야 하는가?
- 리소스의 상태를 업데이트하려면, 어떤 메서드를 사용해야 하는가?
- CRUD12가 아닌 연산을 어떻게 URL에 매핑하는가?
- 특정한 시나리오에 가장 적합한 HTTP 응답은 무엇인가?
- 리소스 상태 표현의 버전은 어떻게 관리할 수 있는가?
- JSON에 포함된 하이퍼링크는 어떻게 구조화하는가?


### 1.7 정리


## URL 식별자 설계

### 2.1 URI
팀 버너스리는 그가 정의한 웹 구조의 원칙(Axioms of Web Architecture)에서 URI의 불투 명성에 대해 다음과 같이 설명하였다.
>식별자로 할 수 있는 유일한 일은 대상을 나타내는 것이다. 역참조를 할 때가 아니라면 다른 정보를 얻기 위해서 URI의 내용을 들여다보지 말아야 한다.

### 2.2 URI 형태
RFC 3986 에서 는 일반적인 URI 문법을 다음과 같이 정의하였다.  
URI = scheme “ :// ” authority “ / ” path [“ ? ” query] [“ # ” fragment ]

**규칙: 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용한다**
포워드 슬래시(/)는 경로(path) 내에서 리소스 간의 계층 관계를 나타내는 데 사용한다.

**규칙: URI 마지막 문자로 슬래시(/)를 포함하지 않는다**
URI 경로 마지막에 있는 슬래시는 아무런 의미가 없지만, 혼란을 초래할 수 있다. 그러므로 REST API의 마지막 글자에 슬래시가 와서는 안 되고 클라이언트에 제공 하는 링크에도 그런 API를 포함하면 안 된다.

**규칙: 하이픈(-)은 URI 가독성을 높이는 데 사용한다**
URI를 쉽게 읽고 해석하기 위해, 긴 URI 경로에 하이픈을 사용해서 가독성을 높 인다. URI에서는 문장 내 공백을 하이픈으로 바꿀 수 있다.

**규칙: 밑줄( _ )은 URI에 사용하지 않는다**
텍스트 뷰어 애플리케이션은 클릭할 수 있다는 표시로 URI에 밑줄을 긋는다. 글꼴 에 따라 다르긴 하지만, 밑줄은 보기 어렵거나 밑줄 때문에 문자가 완전히 가려지 기도 한다. 

**규칙: URI 경로에는 소문자가 적합하다**
URI 경로에 대문자를 사용하면 문제가 될 수 있으므로 소문자를 사용한다. RFC 3986은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정한다.

**규칙: 파일 확장자는 URI에 포함시키지 않는다**
웹에서 점(.) 문자는 URI에서 파일 이름과 확장자를 구분하는 데 사용한다. 하지 만 REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함하지 않아도 된다. 대신 이 확장자는 미디어 타입에 의존하는데, Content-Type 헤더를 통해 전달되고 메시지 바디의 내용을 어떻게 처리할지 결 정한다.


### 2.3 URI 권한 설계
**규칙: API에 있어서 서브 도메인은 일관성 있게 사용해야 한다**
API 최상위 도메인과 1차 서브 도메인 이름(예, soccer.restapi.org)으로 서비스 제공자를 식별해야 한다. API의 전체 도메인 이름에 api라는 서브 도메인을 다음 과 같이 붙여야 한다.

**규칙: 클라이언트 개발자 포탈 서브 도메인 이름은 일관성 있게 만들어야 한다**
보통 REST API는 개발자 포탈DEVELOPER PORTAL이라는 개발자들을 위한 웹 사이트를 지원한다. 이 포탈은 웹 사이트의 문서, 포럼, 포탈 내에서 직접 제공하는 안전한 API 접근키를 이용하여 새로운 클라이언트를 만드는 데 도움을 준다. API가 이러 한 개발자 포탈을 제공하는 경우, 관습적으로 DEVELOPER라는 이름의 서브 도메인 을 만든다.


### 2.4 리소스 모델링
URI 경로는 REST API의 리소스 모델을 다루는데, 포워드 슬래시(/)로 경로 구문 을 나눈다. 이 경로 구문은 리소스 모델 계층에서 유일한 리소스에 해당된다. 리소스 모델링은 API의 주요 개념을 확실하게 잡는 훈련과도 같다. 이 과정은 마치 관계형 데이터베이스 스키마를 정의하기 위한 데이터 모델링이나, 객체 지향 시스 템에서의 클래스 모델링과 유사하다. 


### 2.5 리소스 원형
API 리소스를 모델링할 때, 기본적인 리소스 원형 몇 개를 가지고 시작할 수 있다.

- **도큐먼트**
  도큐먼트 리소스는 객체 인스턴스나 데이터베이스 레코드와 유사한 단일 개념이 다. 일반적으로 도큐먼트의 상태 표현은 값을 가진 필드와 다른 관련 리소스와의 링크 둘 다를 가지게 된다. 기본적인 필드와 링크 기반 구조로 인해, 도큐먼트 타입 은 다른 리소스 원형들의 기반 원형이 된다. 즉, 서로 다른 리소스 원형 세 개는 도 큐먼트 원형에서 분리된 것이라 볼 수 있다.

- **컬렉션**
  컬렉션 리소스는 서버에서 관리하는 디렉터리라는 리소스다. 클라이언트는 새로 운 리소스를 제안해서 컬렉션에 포함시킬 수 있다. 그러나 새로운 리소스를 생성할 지는 컬렉션에 달려 있다. 컬렉션 리소스에 포함하고 싶은 것을 선택하고, 포함된 각 리소스의 URI를 결정한다.

- **스토어**
  스토어는 클라이언트에서 관리하는 리소스 저장소다. 스토어 리소스는 API 클라 이언트가 리소스를 넣거나 빼는 것, 지우는 것에 관여한다. 스토어 스스로 새로운 리소스를 생성하지 못하기 때문에, 새로운 URI를 만들지는 못한다. 대신 리소스는 스토어에 처음 저장될 때, 클라이언트가 선택한 URI를 가진다.

- **컨트롤러**
  컨트롤러 리소스는 절차적인 개념을 모델화한 것이다. 컨트롤러 리소스는 실행 가 능한 함수와 같아서 파라미터(입력 값)와 반환 값(출력 값)이 있다.
  전통적인 웹 애플리케이션이 'HTML form'을 사용하듯이, REST API는 CRUD라 고 알려진 표준적인 메서드와는 논리적으로 매핑되지 않는 애플리케이션 고유의 행동을 컨트롤러 리소스의 도움을 받아 수행한다.


### 2.6 URI 경로 디자인
슬래시(/)로 구분된 각 URI 경로 부분은 다양한 형태로 설계할 수 있다. URI 경로 각 부분에 의미 있는 값들을 줌으로써 REST API 리소스 모델 디자인의 계층적 구 조를 분명하게 표현할 수 있다.


**규칙: 도큐먼트 이름으로는 단수 명사를 사용해야 한다**
- http://api.soccer.restapi.org/leagues/seattle/teams/trebuchet/players/claudio

**규칙: 컬렉션 이름으로는 복수 명사를 사용해야 한다**
- http://api.soccer.restapi.org/leagues/seattle/teams/trebuchet/players

**규칙: 스토어 이름으로는 복수 명사를 사용해야 한다**
- http://api.music.restapi.org/artists/mikemassedotcom/playlists

**규칙: 컨트롤러 이름으로는 동사나 동사구를 사용해야 한다**
프로그램에 사용하는 함수처럼, 컨트롤 리소스를 나타내는 URI는 동작을 포함하는 이름으로 지어야 한다. 예를 들면 다음과 같이 짓는다.
- http://api.college.restapi.org/students/morgan/register
- http://api.example.restapi.org/lists/4324/dedupe 
- http://api.ognom.restapi.org/dbs/reindex 
- http://api.build.restapi.org/qa/nightly/runTestSuite

**규칙: 경로 부분 중 변하는 부분은 유일한 값으로 대체한다**
- REST API의 클라이언트에서는 URI가 하나의 유의미한 리소스 식별자임을 고 려해야 한다. 백엔드 시스템의 식별자(이를 테면, 데이터베이스의 ID와 같은)가 URI 경로에 표시될 수 있지만, 이는 클라이언트 코드 입장에서는 별로 의미가 없 다. URI를 유일한 ID로 사용해야만 기존 클라이언트에 영향을 미치지 않고, REST API의 백엔드 시스템을 개선할 수 있다.

**규칙: CRUD 기능을 나타내는 것은 URI에 사용하지 않는다**
- URI는 리소스를 식별하 는 데만 사용해야 하고, 위에서 설명한 내용을 바탕으로 설계되어야 한다

### 2.7 URI Query 디자인
RFC 3986에서 URI 쿼리 는 선택사항이고 경로와 다른 선택사항인 프래그먼트fragment 사이에 온다.

URI = scheme “://” authority “/” path [ “?” query ] [ “#” fragment ]

